{
  "type": "javascript",
  "terms": [
    {
      "name": "findIndex",
      "trigger": "find index",
      "define": "The 'findIndex()' method is part of the Array object in JavaScript. It returns the index of the first element in the array that satisfies a provided testing function. If no elements satisfy the testing function, it returns -1. The function is not invoked for index properties that have been deleted or are uninitialized. This method does not mutate the array on which it is called, but the function provided will be called for every element in the array until it finds one where it returns a truthy value. If such an element is found, 'findIndex()' immediately returns the element's index. If the callback never returns a truthy value (or the array's length is 0), 'findIndex()' returns -1.\n\nSyntax:\narray.findIndex(callback(element[, index[, array]])[, thisArg])\n\nParameters:\n- 'callback' (required): A function that tests each element of the array. It takes three arguments:\n    - 'element': The current element being processed in the array.\n    - 'index' (optional): The index of the current element in the array.\n    - 'array' (optional): The array on which 'findIndex()' was called.\n- 'thisArg' (optional): An object to use as 'this' when executing the callback function.\n\nReturn Value:\nThe 'findIndex()' method returns the index of the first element in the array that satisfies the provided testing function; otherwise, it returns -1.\n\nExamples:\n1. Finding the index of the first element greater than 10:\nlet numbers = [5, 12, 8, 130, 44];\nlet isLargeNumber = (element) => element > 10;\nlet index = numbers.findIndex(isLargeNumber);\nconsole.log(index); // Output: 1 (index of the element 12)\n\n2. Finding the index of the first negative number:\nlet numbers = [-1, -2, 3, 4, 5];\nlet isNegative = (element) => element < 0;\nlet index = numbers.findIndex(isNegative);\nconsole.log(index); // Output: 0 (index of the element -1)\n\n3. Using 'thisArg' to set the context in the callback function:\nlet numbers = [1, 2, 3, 4, 5];\nlet targetValue = 3;\nfunction isTarget(element) {\n    return element === this.target;\n}\nlet index = numbers.findIndex(isTarget, { target: targetValue });\nconsole.log(index); // Output: 2 (index of the element 3)",
      "example": "\n            // Example 1:\n            let numbers = [5, 12, 8, 130, 44];\n            let isLargeNumber = (element) => element > 10;\n            let index = numbers.findIndex(isLargeNumber);\n            console.log(index); // Output: 1\n\n            // Example 2:\n            let numbers = [-1, -2, 3, 4, 5];\n            let isNegative = (element) => element < 0;\n            let index = numbers.findIndex(isNegative);\n            console.log(index); // Output: 0\n\n            // Example 3:\n            let numbers = [1, 2, 3, 4, 5];\n            let targetValue = 3;\n            function isTarget(element) {\n                return element === this.target;\n            }\n            let index = numbers.findIndex(isTarget, { target: targetValue });\n            console.log(index); // Output: 2\n        "
    },
    {
      "name": "find",
      "define": "The 'find()' method returns the value of the first element in the provided array that satisfies the provided testing function. If no values satisfy the testing function, undefined is returned. The 'find' method executes the callback function once for each index of the array until it finds one where the callback returns a truthy value. If such an element is found, 'find()' immediately returns the value of that element. Otherwise, 'find()' returns undefined.\n\nSyntax:\narray.find(callback(element[, index[, array]])[, thisArg])\n\nParameters:\n- 'callback' (required): A function that tests each element of the array. It takes three arguments:\n    - 'element': The current element being processed in the array.\n    - 'index' (optional): The index of the current element in the array.\n    - 'array' (optional): The array on which 'find()' was called.\n- 'thisArg' (optional): An object to use as 'this' when executing the callback function.\n\nReturn Value:\nThe 'find()' method returns the value of the first element in the array that satisfies the provided testing function; otherwise, it returns undefined.\n\nExamples:\n1. Finding the first element greater than 10:\nlet numbers = [5, 12, 8, 130, 44];\nlet isLargeNumber = (element) => element > 10;\nlet found = numbers.find(isLargeNumber);\nconsole.log(found); // Output: 12 (the first element greater than 10)\n\n2. Finding the first negative number:\nlet numbers = [-1, -2, 3, 4, 5];\nlet isNegative = (element) => element < 0;\nlet found = numbers.find(isNegative);\nconsole.log(found); // Output: -1 (the first negative number)\n\n3. Using 'thisArg' to set the context in the callback function:\nlet fruits = ['apple', 'orange', 'banana'];\nfunction findFruit(fruit) {\n    return this.target === fruit;\n}\nlet targetFruit = 'banana';\nlet found = fruits.find(findFruit, { target: targetFruit });\nconsole.log(found); // Output: 'banana' (the target fruit)\n",
      "example": "\n            // Example 1:\n            let numbers = [5, 12, 8, 130, 44];\n            let isLargeNumber = (element) => element > 10;\n            let found = numbers.find(isLargeNumber);\n            console.log(found); // Output: 12\n\n            // Example 2:\n            let numbers = [-1, -2, 3, 4, 5];\n            let isNegative = (element) => element < 0;\n            let found = numbers.find(isNegative);\n            console.log(found); // Output: -1\n\n            // Example 3:\n            let fruits = ['apple', 'orange', 'banana'];\n            function findFruit(fruit) {\n                return this.target === fruit;\n            }\n            let targetFruit = 'banana';\n            let found = fruits.find(findFruit, { target: targetFruit });\n            console.log(found); // Output: 'banana'\n        "
    },
    {
      "name": "fill",
      "define": "The 'fill()' method changes all elements in an array to a static value, from a start index (default 0) to an end index (default array length). It mutates the original array and returns the modified array.\n\nSyntax:\narray.fill(value[, start[, end]])\n\nParameters:\n- 'value' (required): The value to fill the array with.\n- 'start' (optional): The index to start filling the array (default is 0).\n- 'end' (optional): The index to stop filling the array (default is array.length).\n\nReturn Value:\nThe 'fill()' method returns the modified array.\n\nExamples:\n1. Filling an array with a specific value:\nlet array = [1, 2, 3, 4, 5];\narray.fill(0);\nconsole.log(array); // Output: [0, 0, 0, 0, 0]\n\n2. Filling a portion of an array with a specific value:\nlet array = [1, 2, 3, 4, 5];\narray.fill(0, 1, 4);\nconsole.log(array); // Output: [1, 0, 0, 0, 5]\n\n3. Filling an array with objects:\nlet array = new Array(3);\narray.fill({ key: 'value' });\nconsole.log(array); // Output: [{ key: 'value' }, { key: 'value' }, { key: 'value' }]\n",
      "example": "\n            // Example 1:\n            let array = [1, 2, 3, 4, 5];\n            array.fill(0);\n            console.log(array); // Output: [0, 0, 0, 0, 0]\n\n            // Example 2:\n            let array = [1, 2, 3, 4, 5];\n            array.fill(0, 1, 4);\n            console.log(array); // Output: [1, 0, 0, 0, 5]\n\n            // Example 3:\n            let array = new Array(3);\n            array.fill({ key: 'value' });\n            console.log(array); // Output: [{ key: 'value' }, { key: 'value' }, { key: 'value' }]\n        "
    },
    {
      "name": "from",
      "define": "The 'from()' method is a static method of the Array object that creates a new shallow-copied array from an array-like or iterable object. It allows converting objects that are not actual arrays (such as NodeList, arguments, or strings) into arrays.\n\nSyntax:\nArray.from(arrayLike[, mapFn[, thisArg]])\n\nParameters:\n- 'arrayLike' (required): An array-like or iterable object to convert to an array.\n- 'mapFn' (optional): A function to map each element of the array.\n- 'thisArg' (optional): An object to use as 'this' when executing the map function.\n\nReturn Value:\nThe 'from()' method returns a new Array instance.\n\nExamples:\n1. Converting a string to an array:\nlet str = 'hello';\nlet array = Array.from(str);\nconsole.log(array); // Output: ['h', 'e', 'l', 'l', 'o']\n\n2. Converting a NodeList to an array:\nlet nodeList = document.querySelectorAll('p');\nlet array = Array.from(nodeList);\nconsole.log(array); // Output: [p1, p2, p3, ...]\n\n3. Using the map function to manipulate elements during conversion:\nlet numbers = [1, 2, 3, 4, 5];\nlet doubledArray = Array.from(numbers, (num) => num * 2);\nconsole.log(doubledArray); // Output: [2, 4, 6, 8, 10]\n",
      "example": "\n            // Example 1:\n            let str = 'hello';\n            let array = Array.from(str);\n            console.log(array); // Output: ['h', 'e', 'l', 'l', 'o']\n\n            // Example 2:\n            let nodeList = document.querySelectorAll('p');\n            let array = Array.from(nodeList);\n            console.log(array); // Output: [p1, p2, p3, ...]\n\n            // Example 3:\n            let numbers = [1, 2, 3, 4, 5];\n            let doubledArray = Array.from(numbers, (num) => num * 2);\n            console.log(doubledArray); // Output: [2, 4, 6, 8, 10]\n        "
    },
    {
      "name": "forEach",
      "trigger": "for each",
      "define": "The 'forEach()' method executes a provided function once for each array element. It is a higher-order function used for iterating over arrays.\n\nSyntax:\narray.forEach(callback(currentValue[, index[, array]])[, thisArg])\n\nParameters:\n- 'callback' (required): A function to execute for each element in the array. It takes three arguments:\n    - 'currentValue': The current element being processed in the array.\n    - 'index' (optional): The index of the current element in the array.\n    - 'array' (optional): The array on which 'forEach()' was called.\n- 'thisArg' (optional): An object to use as 'this' when executing the callback function.\n\nReturn Value:\nThe 'forEach()' method does not return a value. It is executed for its side effects.\n\nExamples:\n1. Using 'forEach()' to log each element in the array:\nlet numbers = [1, 2, 3, 4, 5];\nnumbers.forEach((num) => {\n    console.log(num);\n});\n// Output: 1\n//         2\n//         3\n//         4\n//         5\n\n2. Using 'forEach()' with an object method:\nlet obj = {\n    name: 'John',\n    age: 30,\n    country: 'USA',\n};\nObject.keys(obj).forEach((key) => {\n    console.log(key + ': ' + obj[key]);\n});\n// Output: name: John\n//         age: 30\n//         country: USA\n\n3. Using 'forEach()' with 'thisArg':\nfunction logEvenNumbers(num) {\n    if (num % 2 === 0) {\n        console.log(num);\n    }\n}\nlet numbers = [1, 2, 3, 4, 5];\nnumbers.forEach(logEvenNumbers, { target: 2 });\n// Output: 2\n//         4\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n            numbers.forEach((num) => {\n                console.log(num);\n            });\n            // Output: 1\n            //         2\n            //         3\n            //         4\n            //         5\n\n            // Example 2:\n            let obj = {\n                name: 'John',\n                age: 30,\n                country: 'USA',\n            };\n            Object.keys(obj).forEach((key) => {\n                console.log(key + ': ' + obj[key]);\n            });\n            // Output: name: John\n            //         age: 30\n            //         country: USA\n\n            // Example 3:\n            function logEvenNumbers(num) {\n                if (num % 2 === 0) {\n                    console.log(num);\n                }\n            }\n            let numbers = [1, 2, 3, 4, 5];\n            numbers.forEach(logEvenNumbers, { target: 2 });\n            // Output: 2\n            //         4\n        "
    },
    {
      "name": "filter",
      "define": "The 'filter()' method creates a new array with all elements that pass the test implemented by the provided function. It is a higher-order function used for filtering elements in an array based on a condition.\n\nSyntax:\narray.filter(callback(element[, index[, array]])[, thisArg])\n\nParameters:\n- 'callback' (required): A function that tests each element of the array. It takes three arguments:\n    - 'element': The current element being processed in the array.\n    - 'index' (optional): The index of the current element in the array.\n    - 'array' (optional): The array on which 'filter()' was called.\n- 'thisArg' (optional): An object to use as 'this' when executing the callback function.\n\nReturn Value:\nThe 'filter()' method returns a new array containing all elements that pass the test implemented by the provided callback function.\n\nExamples:\n1. Filtering even numbers from an array:\nlet numbers = [1, 2, 3, 4, 5];\nlet evenNumbers = numbers.filter((num) => num % 2 === 0);\nconsole.log(evenNumbers); // Output: [2, 4]\n\n2. Filtering objects based on a condition:\nlet products = [\n    { id: 1, name: 'Laptop', price: 1000 },\n    { id: 2, name: 'Phone', price: 500 },\n    { id: 3, name: 'Tablet', price: 300 },\n];\nlet affordableProducts = products.filter((product) => product.price < 800);\nconsole.log(affordableProducts);\n// Output: [\n//     { id: 2, name: 'Phone', price: 500 },\n//     { id: 3, name: 'Tablet', price: 300 },\n// ]\n\n3. Filtering elements using 'thisArg':\nfunction isBelowThreshold(value) {\n    return value < this.threshold;\n}\nlet numbers = [1, 2, 3, 4, 5];\nlet filteredNumbers = numbers.filter(isBelowThreshold, { threshold: 4 });\nconsole.log(filteredNumbers); // Output: [1, 2, 3]\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n            let evenNumbers = numbers.filter((num) => num % 2 === 0);\n            console.log(evenNumbers); // Output: [2, 4]\n\n            // Example 2:\n            let products = [\n                { id: 1, name: 'Laptop', price: 1000 },\n                { id: 2, name: 'Phone', price: 500 },\n                { id: 3, name: 'Tablet', price: 300 },\n            ];\n            let affordableProducts = products.filter((product) => product.price < 800);\n            console.log(affordableProducts);\n            // Output: [\n            //     { id: 2, name: 'Phone', price: 500 },\n            //     { id: 3, name: 'Tablet', price: 300 },\n            // ]\n\n            // Example 3:\n            function isBelowThreshold(value) {\n                return value < this.threshold;\n            }\n            let numbers = [1, 2, 3, 4, 5];\n            let filteredNumbers = numbers.filter(isBelowThreshold, { threshold: 4 });\n            console.log(filteredNumbers); // Output: [1, 2, 3]\n        "
    },
    {
      "name": "flat",
      "define": "The 'flat()' method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth. It effectively flattens nested arrays.\n\nSyntax:\narray.flat([depth])\n\nParameters:\n- 'depth' (optional): The depth level specifying how deep a nested array structure should be flattened. The default is 1.\n\nReturn Value:\nThe 'flat()' method returns a new array with the sub-array elements concatenated to the specified depth.\n\nExamples:\n1. Flattening a nested array:\nlet nestedArray = [1, [2, 3], [4, [5]]];\nlet flattenedArray = nestedArray.flat();\nconsole.log(flattenedArray); // Output: [1, 2, 3, 4, [5]]\n\n2. Flattening a nested array with depth specified:\nlet deeplyNestedArray = [1, [2, [3, [4]]]];\nlet flattenedArray = deeplyNestedArray.flat(Infinity);\nconsole.log(flattenedArray); // Output: [1, 2, 3, 4]\n",
      "example": "\n            // Example 1:\n            let nestedArray = [1, [2, 3], [4, [5]]];\n            let flattenedArray = nestedArray.flat();\n            console.log(flattenedArray); // Output: [1, 2, 3, 4, [5]]\n\n            // Example 2:\n            let deeplyNestedArray = [1, [2, [3, [4]]]];\n            let flattenedArray = deeplyNestedArray.flat(Infinity);\n            console.log(flattenedArray); // Output: [1, 2, 3, 4]\n        "
    },
    {
      "name": "flatMap",
      "trigger": "flat map",
      "define": "The 'flatMap()' method combines 'map()' and 'flat()' methods into one operation. It first maps each element using a mapping function, then flattens the result into a new array. It is useful for applying a function to each element and then flattening the result.\n\nSyntax:\narray.flatMap(callback(element[, index[, array]])[, thisArg])\n\nParameters:\n- 'callback' (required): A function that produces an element of the new array, with each element mapped by the provided callback function. It takes three arguments:\n    - 'element': The current element being processed in the array.\n    - 'index' (optional): The index of the current element in the array.\n    - 'array' (optional): The array on which 'flatMap()' was called.\n- 'thisArg' (optional): An object to use as 'this' when executing the callback function.\n\nReturn Value:\nThe 'flatMap()' method returns a new array with the mapped and flattened elements.\n\nExamples:\n1. Mapping and flattening array elements:\nlet words = ['hello', 'world'];\nlet mappedAndFlattened = words.flatMap((word) => word.split(''));\nconsole.log(mappedAndFlattened); // Output: ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']\n\n2. Mapping and flattening with a function returning arrays:\nlet numbers = [1, 2, 3, 4];\nlet mappedAndFlattened = numbers.flatMap((num) => [num * 2, num * 3]);\nconsole.log(mappedAndFlattened); // Output: [2, 3, 4, 6, 6, 9, 8, 12]\n",
      "example": "\n            // Example 1:\n            let words = ['hello', 'world'];\n            let mappedAndFlattened = words.flatMap((word) => word.split(''));\n            console.log(mappedAndFlattened); // Output: ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']\n\n            // Example 2:\n            let numbers = [1, 2, 3, 4];\n            let mappedAndFlattened = numbers.flatMap((num) => [num * 2, num * 3]);\n            console.log(mappedAndFlattened); // Output: [2, 3, 4, 6, 6, 9, 8, 12]\n        "
    },
    {
      "name": "includes",
      "define": "The 'includes()' method determines whether an array includes a certain value. It returns 'true' if the array contains the value; otherwise, it returns 'false'. The method performs a strict equality comparison (===) for the search.\n\nSyntax:\narray.includes(searchElement[, fromIndex])\n\nParameters:\n- 'searchElement' (required): The element to search for in the array.\n- 'fromIndex' (optional): The index to start the search from. If not provided, the search starts from index 0.\n\nReturn Value:\nThe 'includes()' method returns 'true' if the array contains the specified element; otherwise, it returns 'false'.\n\nExamples:\n1. Checking if an array includes an element:\nlet fruits = ['apple', 'orange', 'banana'];\nlet includesOrange = fruits.includes('orange');\nconsole.log(includesOrange); // Output: true\n\n2. Checking from a specific index:\nlet numbers = [1, 2, 3, 4, 5];\nlet includes3 = numbers.includes(3, 2);\nconsole.log(includes3); // Output: true\n\n3. Checking for NaN:\nlet values = [1, NaN, 3];\nlet includesNaN = values.includes(NaN);\nconsole.log(includesNaN); // Output: true\n",
      "example": "\n            // Example 1:\n            let fruits = ['apple', 'orange', 'banana'];\n            let includesOrange = fruits.includes('orange');\n            console.log(includesOrange); // Output: true\n\n            // Example 2:\n            let numbers = [1, 2, 3, 4, 5];\n            let includes3 = numbers.includes(3, 2);\n            console.log(includes3); // Output: true\n\n            // Example 3:\n            let values = [1, NaN, 3];\n            let includesNaN = values.includes(NaN);\n            console.log(includesNaN); // Output: true\n        "
    },
    {
      "name": "indexOf",
      "trigger": "index of",
      "define": "The 'indexOf()' method returns the first index at which a given element can be found in the array or -1 if it is not present. The method performs a strict equality comparison (===) for the search.\n\nSyntax:\narray.indexOf(searchElement[, fromIndex])\n\nParameters:\n- 'searchElement' (required): The element to search for in the array.\n- 'fromIndex' (optional): The index to start the search from. If not provided, the search starts from index 0.\n\nReturn Value:\nThe 'indexOf()' method returns the first index at which the specified element is found in the array; otherwise, it returns -1.\n\nExamples:\n1. Finding the index of an element in an array:\nlet numbers = [1, 2, 3, 4, 3, 5];\nlet index = numbers.indexOf(3);\nconsole.log(index); // Output: 2 (index of the first occurrence of 3)\n\n2. Finding the index from a specific starting point:\nlet numbers = [1, 2, 3, 4, 3, 5];\nlet index = numbers.indexOf(3, 3);\nconsole.log(index); // Output: 4 (index of the first occurrence of 3 from index 3)\n\n3. Searching for a non-existent element:\nlet fruits = ['apple', 'orange', 'banana'];\nlet index = fruits.indexOf('grape');\nconsole.log(index); // Output: -1 (element 'grape' is not found)\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 3, 5];\n            let index = numbers.indexOf(3);\n            console.log(index); // Output: 2 (index of the first occurrence of 3)\n\n            // Example 2:\n            let numbers = [1, 2, 3, 4, 3, 5];\n            let index = numbers.indexOf(3, 3);\n            console.log(index); // Output: 4 (index of the first occurrence of 3 from index 3)\n\n            // Example 3:\n            let fruits = ['apple', 'orange', 'banana'];\n            let index = fruits.indexOf('grape');\n            console.log(index); // Output: -1 (element 'grape' is not found)\n        "
    },
    {
      "name": "join",
      "define": "The 'join()' method creates and returns a new string by concatenating all elements in an array using a specified separator. By default, the separator is a comma (','), but it can be customized.\n\nSyntax:\narray.join([separator])\n\nParameters:\n- 'separator' (optional): The string used to separate the array elements in the resulting string. If not provided, a comma (',') is used as the default separator.\n\nReturn Value:\nThe 'join()' method returns a new string containing all array elements joined by the specified separator.\n\nExamples:\n1. Joining elements of an array with a default separator:\nlet fruits = ['apple', 'orange', 'banana'];\nlet result = fruits.join();\nconsole.log(result); // Output: 'apple,orange,banana'\n\n2. Joining elements with a custom separator:\nlet numbers = [1, 2, 3, 4, 5];\nlet result = numbers.join('-');\nconsole.log(result); // Output: '1-2-3-4-5'\n",
      "example": "\n            // Example 1:\n            let fruits = ['apple', 'orange', 'banana'];\n            let result = fruits.join();\n            console.log(result); // Output: 'apple,orange,banana'\n\n            // Example 2:\n            let numbers = [1, 2, 3, 4, 5];\n            let result = numbers.join('-');\n            console.log(result); // Output: '1-2-3-4-5'\n        "
    },
    {
      "name": "keys",
      "define": "The 'keys()' method returns a new Array Iterator object that contains the keys (indices) of each element in the array. It is used to iterate over the indices of an array.\n\nSyntax:\narray.keys()\n\nReturn Value:\nThe 'keys()' method returns a new Array Iterator object.\n\nExamples:\n1. Using 'keys()' to iterate over array indices:\nlet fruits = ['apple', 'orange', 'banana'];\nlet keysIterator = fruits.keys();\nfor (let key of keysIterator) {\n    console.log(key); // Output: 0, 1, 2\n}\n\n2. Converting the Array Iterator to an array:\nlet fruits = ['apple', 'orange', 'banana'];\nlet keysIterator = fruits.keys();\nlet keysArray = Array.from(keysIterator);\nconsole.log(keysArray); // Output: [0, 1, 2]\n",
      "example": "\n            // Example 1:\n            let fruits = ['apple', 'orange', 'banana'];\n            let keysIterator = fruits.keys();\n            for (let key of keysIterator) {\n                console.log(key); // Output: 0, 1, 2\n            }\n\n            // Example 2:\n            let fruits = ['apple', 'orange', 'banana'];\n            let keysIterator = fruits.keys();\n            let keysArray = Array.from(keysIterator);\n            console.log(keysArray); // Output: [0, 1, 2]\n        "
    },
    {
      "name": "lastIndexOf",
      "trigger": "last index",
      "define": "The 'lastIndexOf()' method returns the last index at which a given element can be found in the array or -1 if it is not present. The method performs a strict equality comparison (===) for the search.\n\nSyntax:\narray.lastIndexOf(searchElement[, fromIndex])\n\nParameters:\n- 'searchElement' (required): The element to search for in the array.\n- 'fromIndex' (optional): The index to start the search from. If not provided, the search starts from the last element of the array.\n\nReturn Value:\nThe 'lastIndexOf()' method returns the last index at which the specified element is found in the array; otherwise, it returns -1.\n\nExamples:\n1. Finding the last index of an element in an array:\nlet numbers = [1, 2, 3, 4, 3, 5];\nlet lastIndex = numbers.lastIndexOf(3);\nconsole.log(lastIndex); // Output: 4 (last index of 3)\n\n2. Finding the last index from a specific starting point:\nlet numbers = [1, 2, 3, 4, 3, 5];\nlet lastIndex = numbers.lastIndexOf(3, 3);\nconsole.log(lastIndex); // Output: 2 (last index of 3 from index 3)\n\n3. Searching for a non-existent element:\nlet fruits = ['apple', 'orange', 'banana'];\nlet lastIndex = fruits.lastIndexOf('grape');\nconsole.log(lastIndex); // Output: -1 (element 'grape' is not found)\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 3, 5];\n            let lastIndex = numbers.lastIndexOf(3);\n            console.log(lastIndex); // Output: 4 (last index of 3)\n\n            // Example 2:\n            let numbers = [1, 2, 3, 4, 3, 5];\n            let lastIndex = numbers.lastIndexOf(3, 3);\n            console.log(lastIndex); // Output: 2 (last index of 3 from index 3)\n\n            // Example 3:\n            let fruits = ['apple', 'orange', 'banana'];\n            let lastIndex = fruits.lastIndexOf('grape');\n            console.log(lastIndex); // Output: -1 (element 'grape' is not found)\n        "
    },
    {
      "name": "map",
      "define": "The 'map()' method creates a new array with the results of calling a provided function on every element in the calling array. It is a higher-order function used for transforming array elements.\n\nSyntax:\narray.map(callback(element[, index[, array]])[, thisArg])\n\nParameters:\n- 'callback' (required): A function that produces an element of the new array, with each element in the original array mapped by the provided callback function. It takes three arguments:\n    - 'element': The current element being processed in the array.\n    - 'index' (optional): The index of the current element in the array.\n    - 'array' (optional): The array on which 'map()' was called.\n- 'thisArg' (optional): An object to use as 'this' when executing the callback function.\n\nReturn Value:\nThe 'map()' method returns a new array with the results of the provided callback function applied to each element of the calling array.\n\nExamples:\n1. Mapping each element to its square:\nlet numbers = [1, 2, 3, 4, 5];\nlet squaredNumbers = numbers.map((num) => num * num);\nconsole.log(squaredNumbers); // Output: [1, 4, 9, 16, 25]\n\n2. Mapping an array of objects:\nlet people = [\n    { name: 'Alice', age: 30 },\n    { name: 'Bob', age: 25 },\n    { name: 'Charlie', age: 35 },\n];\nlet names = people.map((person) => person.name);\nconsole.log(names); // Output: ['Alice', 'Bob', 'Charlie']\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n            let squaredNumbers = numbers.map((num) => num * num);\n            console.log(squaredNumbers); // Output: [1, 4, 9, 16, 25]\n\n            // Example 2:\n            let people = [\n                { name: 'Alice', age: 30 },\n                { name: 'Bob', age: 25 },\n                { name: 'Charlie', age: 35 },\n            ];\n            let names = people.map((person) => person.name);\n            console.log(names); // Output: ['Alice', 'Bob', 'Charlie']\n        "
    },
    {
      "name": "pop",
      "define": "The 'pop()' method removes the last element from an array and returns that element. This method changes the length of the array.\n\nSyntax:\narray.pop()\n\nReturn Value:\nThe 'pop()' method returns the removed element from the array. If the array is empty, 'undefined' is returned.\n\nExamples:\n1. Removing the last element from an array:\nlet numbers = [1, 2, 3, 4, 5];\nlet removedElement = numbers.pop();\nconsole.log(numbers); // Output: [1, 2, 3, 4]\nconsole.log(removedElement); // Output: 5\n\n2. Removing the last element from an empty array:\nlet emptyArray = [];\nlet removedElement = emptyArray.pop();\nconsole.log(emptyArray); // Output: []\nconsole.log(removedElement); // Output: undefined\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n            let removedElement = numbers.pop();\n            console.log(numbers); // Output: [1, 2, 3, 4]\n            console.log(removedElement); // Output: 5\n\n            // Example 2:\n            let emptyArray = [];\n            let removedElement = emptyArray.pop();\n            console.log(emptyArray); // Output: []\n            console.log(removedElement); // Output: undefined\n        "
    },
    {
      "name": "push",
      "define": "The 'push()' method adds one or more elements to the end of an array and returns the new length of the array.\n\nSyntax:\narray.push(element1[, element2[, ...[, elementN]]])\n\nParameters:\n- 'element1' (required): The first element to add to the end of the array.\n- 'element2', 'element3', ..., 'elementN' (optional): Additional elements to add to the end of the array.\n\nReturn Value:\nThe 'push()' method returns the new length of the array after adding the specified elements.\n\nExamples:\n1. Adding elements to the end of an array:\nlet numbers = [1, 2, 3];\nlet newLength = numbers.push(4, 5);\nconsole.log(numbers); // Output: [1, 2, 3, 4, 5]\nconsole.log(newLength); // Output: 5\n\n2. Adding elements to an empty array:\nlet emptyArray = [];\nlet newLength = emptyArray.push('a', 'b', 'c');\nconsole.log(emptyArray); // Output: ['a', 'b', 'c']\nconsole.log(newLength); // Output: 3\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3];\n            let newLength = numbers.push(4, 5);\n            console.log(numbers); // Output: [1, 2, 3, 4, 5]\n            console.log(newLength); // Output: 5\n\n            // Example 2:\n            let emptyArray = [];\n            let newLength = emptyArray.push('a', 'b', 'c');\n            console.log(emptyArray); // Output: ['a', 'b', 'c']\n            console.log(newLength); // Output: 3\n        "
    },
    {
      "name": "reduce",
      "define": "The 'reduce()' method executes a reducer function on each element of the array, resulting in a single output value. It is often used for calculating the cumulative result of array elements.\n\nSyntax:\narray.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])\n\nParameters:\n- 'callback' (required): A function that is called for each element in the array. It takes four arguments:\n    - 'accumulator': The accumulated result from previous iterations. It is the value returned from the previous invocation of the callback function.\n    - 'currentValue': The current element being processed in the array.\n    - 'index' (optional): The index of the current element in the array.\n    - 'array' (optional): The array on which 'reduce()' was called.\n- 'initialValue' (optional): A value used as the initial value for the 'accumulator' in the first call to the callback function.\n\nReturn Value:\nThe 'reduce()' method returns the final accumulated value.\n\nExamples:\n1. Summing all elements in an array:\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue);\nconsole.log(sum); // Output: 15\n\n2. Calculating the product of all elements:\nlet numbers = [2, 3, 4];\nlet product = numbers.reduce((accumulator, currentValue) => accumulator * currentValue);\nconsole.log(product); // Output: 24\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n            let sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue);\n            console.log(sum); // Output: 15\n\n            // Example 2:\n            let numbers = [2, 3, 4];\n            let product = numbers.reduce((accumulator, currentValue) => accumulator * currentValue);\n            console.log(product); // Output: 24\n        "
    },
    {
      "name": "reduceRight",
      "trigger": "reduce right",
      "define": "The 'reduceRight()' method is similar to 'reduce()', but it executes the reducer function starting from the last element towards the first element of the array.\n\nSyntax:\narray.reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue])\n\nParameters:\n- 'callback' (required): A function that is called for each element in the array, starting from the last element to the first. It takes four arguments:\n    - 'accumulator': The accumulated result from previous iterations. It is the value returned from the previous invocation of the callback function.\n    - 'currentValue': The current element being processed in the array.\n    - 'index' (optional): The index of the current element in the array.\n    - 'array' (optional): The array on which 'reduceRight()' was called.\n- 'initialValue' (optional): A value used as the initial value for the 'accumulator' in the first call to the callback function.\n\nReturn Value:\nThe 'reduceRight()' method returns the final accumulated value.\n\nExamples:\n1. Concatenating array elements in reverse order:\nlet fruits = ['apple', 'orange', 'banana'];\nlet reversedString = fruits.reduceRight((accumulator, currentValue) => accumulator + ' ' + currentValue);\nconsole.log(reversedString); // Output: 'banana orange apple'\n",
      "example": "\n            // Example 1:\n            let fruits = ['apple', 'orange', 'banana'];\n            let reversedString = fruits.reduceRight((accumulator, currentValue) => accumulator + ' ' + currentValue);\n            console.log(reversedString); // Output: 'banana orange apple'\n        "
    },
    {
      "name": "reverse",
      "define": "The 'reverse()' method reverses the order of the elements in an array. The first element becomes the last, and the last element becomes the first.\n\nSyntax:\narray.reverse()\n\nReturn Value:\nThe 'reverse()' method modifies the original array and returns the reversed array. It does not create a new array.\n\nExamples:\n1. Reversing an array:\nlet numbers = [1, 2, 3, 4, 5];\nnumbers.reverse();\nconsole.log(numbers); // Output: [5, 4, 3, 2, 1]\n\n2. Reversing an array of strings:\nlet colors = ['red', 'green', 'blue'];\ncolors.reverse();\nconsole.log(colors); // Output: ['blue', 'green', 'red']\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n            numbers.reverse();\n            console.log(numbers); // Output: [5, 4, 3, 2, 1]\n\n            // Example 2:\n            let colors = ['red', 'green', 'blue'];\n            colors.reverse();\n            console.log(colors); // Output: ['blue', 'green', 'red']\n        "
    },
    {
      "name": "shift",
      "define": "The 'shift()' method removes the first element from an array and returns that element. This method changes the length of the array.\n\nSyntax:\narray.shift()\n\nReturn Value:\nThe 'shift()' method returns the removed element from the array. If the array is empty, 'undefined' is returned.\n\nExamples:\n1. Removing the first element from an array:\nlet numbers = [1, 2, 3, 4, 5];\nlet removedElement = numbers.shift();\nconsole.log(numbers); // Output: [2, 3, 4, 5]\nconsole.log(removedElement); // Output: 1\n\n2. Removing the first element from an empty array:\nlet emptyArray = [];\nlet removedElement = emptyArray.shift();\nconsole.log(emptyArray); // Output: []\nconsole.log(removedElement); // Output: undefined\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n            let removedElement = numbers.shift();\n            console.log(numbers); // Output: [2, 3, 4, 5]\n            console.log(removedElement); // Output: 1\n\n            // Example 2:\n            let emptyArray = [];\n            let removedElement = emptyArray.shift();\n            console.log(emptyArray); // Output: []\n            console.log(removedElement); // Output: undefined\n        "
    },
    {
      "name": "slice",
      "define": "The 'slice()' method extracts a section of an array and returns a new array containing the selected elements. It does not modify the original array.\n\nSyntax:\narray.slice([start[, end]])\n\nParameters:\n- 'start' (optional): The beginning index of the extraction. If 'start' is undefined, 'slice()' will start from index 0. A negative 'start' index can be used to specify an offset from the end of the array.\n- 'end' (optional): The ending index of the extraction. 'slice()' extracts elements up to, but not including, 'end'. If 'end' is omitted, 'slice()' extracts elements up to the end of the array. A negative 'end' index can be used to specify an offset from the end of the array.\n\nReturn Value:\nThe 'slice()' method returns a new array containing the extracted elements. If 'start' is greater than or equal to the length of the array, an empty array is returned.\n\nExamples:\n1. Slicing elements from an array:\nlet numbers = [1, 2, 3, 4, 5];\nlet slicedNumbers = numbers.slice(1, 4);\nconsole.log(slicedNumbers); // Output: [2, 3, 4]\n\n2. Slicing elements with negative indices:\nlet numbers = [1, 2, 3, 4, 5];\nlet slicedNumbers = numbers.slice(-3, -1);\nconsole.log(slicedNumbers); // Output: [3, 4]\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n            let slicedNumbers = numbers.slice(1, 4);\n            console.log(slicedNumbers); // Output: [2, 3, 4]\n\n            // Example 2:\n            let numbers = [1, 2, 3, 4, 5];\n            let slicedNumbers = numbers.slice(-3, -1);\n            console.log(slicedNumbers); // Output: [3, 4]\n        "
    },
    {
      "name": "some",
      "define": "The 'some()' method tests whether at least one element in the array passes the test implemented by the provided callback function. It returns 'true' if any element satisfies the condition, otherwise 'false'.\n\nSyntax:\narray.some(callback(element[, index[, array]])[, thisArg])\n\nParameters:\n- 'callback' (required): A function that tests each element of the array. It takes three arguments:\n    - 'element': The current element being processed in the array.\n    - 'index' (optional): The index of the current element in the array.\n    - 'array' (optional): The array on which 'some()' was called.\n- 'thisArg' (optional): An object to use as 'this' when executing the callback function.\n\nReturn Value:\nThe 'some()' method returns 'true' if the callback function returns 'true' for at least one element in the array; otherwise, it returns 'false'.\n\nExamples:\n1. Checking if any element is greater than 3:\nlet numbers = [1, 2, 3, 4, 5];\nlet hasGreaterThanThree = numbers.some((num) => num > 3);\nconsole.log(hasGreaterThanThree); // Output: true\n\n2. Checking for even numbers:\nlet numbers = [1, 2, 3, 4, 5];\nlet hasEvenNumber = numbers.some((num) => num % 2 === 0);\nconsole.log(hasEvenNumber); // Output: true\n\n3. Using 'thisArg' to check for a threshold:\nlet threshold = 10;\nlet values = [5, 15, 25];\nlet hasThresholdValue = values.some(function (value) {\n    return value >= this.threshold;\n}, { threshold });\nconsole.log(hasThresholdValue); // Output: true\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n            let hasGreaterThanThree = numbers.some((num) => num > 3);\n            console.log(hasGreaterThanThree); // Output: true\n\n            // Example 2:\n            let numbers = [1, 2, 3, 4, 5];\n            let hasEvenNumber = numbers.some((num) => num % 2 === 0);\n            console.log(hasEvenNumber); // Output: true\n\n            // Example 3:\n            let threshold = 10;\n            let values = [5, 15, 25];\n            let hasThresholdValue = values.some(function (value) {\n                return value >= this.threshold;\n            }, { threshold });\n            console.log(hasThresholdValue); // Output: true\n        "
    },
    {
      "name": "sort",
      "define": "The 'sort()' method sorts the elements of an array in place and returns the sorted array. The default sort order is lexicographic (string-based) ascending. It modifies the original array and does not create a new one.\n\nSyntax:\narray.sort([compareFunction])\n\nParameters:\n- 'compareFunction' (optional): A function that defines the sort order. If omitted, the array elements are converted to strings and sorted based on their UTF-16 code units. The compare function should return a negative value if 'a' should come before 'b', a positive value if 'a' should come after 'b', or 0 if 'a' and 'b' are considered equal.\n\nReturn Value:\nThe 'sort()' method returns the sorted array. Note that the original array is also modified.\n\nExamples:\n1. Sorting an array of numbers in ascending order:\nlet numbers = [3, 1, 4, 2, 5];\nnumbers.sort();\nconsole.log(numbers); // Output: [1, 2, 3, 4, 5]\n\n2. Sorting an array of strings in alphabetical order:\nlet fruits = ['banana', 'orange', 'apple'];\nfruits.sort();\nconsole.log(fruits); // Output: ['apple', 'banana', 'orange']\n\n3. Sorting an array of objects based on a property:\nlet people = [\n    { name: 'Alice', age: 30 },\n    { name: 'Bob', age: 25 },\n    { name: 'Charlie', age: 35 },\n];\npeople.sort((a, b) => a.age - b.age);\nconsole.log(people);\n// Output: [\n//   { name: 'Bob', age: 25 },\n//   { name: 'Alice', age: 30 },\n//   { name: 'Charlie', age: 35 }\n// ]\n",
      "example": "\n            // Example 1:\n            let numbers = [3, 1, 4, 2, 5];\n            numbers.sort();\n            console.log(numbers); // Output: [1, 2, 3, 4, 5]\n\n            // Example 2:\n            let fruits = ['banana', 'orange', 'apple'];\n            fruits.sort();\n            console.log(fruits); // Output: ['apple', 'banana', 'orange']\n\n            // Example 3:\n            let people = [\n                { name: 'Alice', age: 30 },\n                { name: 'Bob', age: 25 },\n                { name: 'Charlie', age: 35 },\n            ];\n            people.sort((a, b) => a.age - b.age);\n            console.log(people);\n            // Output: [\n            //   { name: 'Bob', age: 25 },\n            //   { name: 'Alice', age: 30 },\n            //   { name: 'Charlie', age: 35 }\n            // ]\n        "
    },
    {
      "name": "splice",
      "define": "The 'splice()' method changes the content of an array by removing or replacing existing elements and/or adding new elements in place. It modifies the original array and returns an array containing the removed elements, if any.\n\nSyntax:\narray.splice(start[, deleteCount[, item1[, item2[, ...]]]])\n\nParameters:\n- 'start' (required): The index at which to start changing the array. If negative, it specifies an offset from the end of the array.\n- 'deleteCount' (optional): The number of elements to remove from the array. If 'deleteCount' is 0, no elements are removed. If 'deleteCount' is not provided, all elements from 'start' to the end of the array will be removed.\n- 'item1', 'item2', ... (optional): The elements to add to the array, beginning at the 'start' index. If no elements are specified, 'splice()' will only remove elements.\n\nReturn Value:\nThe 'splice()' method returns an array containing the elements that were removed. If no elements are removed, an empty array is returned.\n\nExamples:\n1. Removing elements from an array:\nlet numbers = [1, 2, 3, 4, 5];\nlet removedElements = numbers.splice(1, 2);\nconsole.log(numbers); // Output: [1, 4, 5]\nconsole.log(removedElements); // Output: [2, 3]\n\n2. Replacing elements in an array:\nlet colors = ['red', 'green', 'blue'];\nlet replacedElements = colors.splice(1, 1, 'yellow', 'orange');\nconsole.log(colors); // Output: ['red', 'yellow', 'orange', 'blue']\nconsole.log(replacedElements); // Output: ['green']\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n            let removedElements = numbers.splice(1, 2);\n            console.log(numbers); // Output: [1, 4, 5]\n            console.log(removedElements); // Output: [2, 3]\n\n            // Example 2:\n            let colors = ['red', 'green', 'blue'];\n            let replacedElements = colors.splice(1, 1, 'yellow', 'orange');\n            console.log(colors); // Output: ['red', 'yellow', 'orange', 'blue']\n            console.log(replacedElements); // Output: ['green']\n        "
    },
    {
      "name": "toLocaleString",
      "trigger": "locale string",
      "define": "The 'toLocaleString()' method returns a string representing the elements of an array. The elements are converted to strings using their 'toLocaleString()' methods and then concatenated into a single string. This method does not modify the original array.\n\nSyntax:\narray.toLocaleString([locales[, options]])\n\nParameters:\n- 'locales' (optional): A string with a BCP 47 language tag or an array of such strings, indicating the language(s) to be used for formatting. If not provided, the default locale of the JavaScript runtime is used.\n- 'options' (optional): An object with configuration options. It can have properties like 'style' (e.g., 'decimal', 'currency', 'percent') and 'currency' (e.g., 'USD', 'EUR') to customize the formatting.\n\nReturn Value:\nThe 'toLocaleString()' method returns a string representing the elements of the array.\n\nExamples:\n1. Converting an array to a localized string:\nlet numbers = [1000, 2000, 3000];\nlet localizedString = numbers.toLocaleString();\nconsole.log(localizedString); // Output: '1,000,2,000,3,000'\n\n2. Using locales and options for formatting:\nlet numbers = [1000, 2000, 3000];\nlet localizedString = numbers.toLocaleString('de-DE', { style: 'currency', currency: 'EUR' });\nconsole.log(localizedString); // Output: '1.000,00 €,2.000,00 €,3.000,00 €'\n",
      "example": "\n            // Example 1:\n            let numbers = [1000, 2000, 3000];\n            let localizedString = numbers.toLocaleString();\n            console.log(localizedString); // Output: '1,000,2,000,3,000'\n\n            // Example 2:\n            let numbers = [1000, 2000, 3000];\n            let localizedString = numbers.toLocaleString('de-DE', { style: 'currency', currency: 'EUR' });\n            console.log(localizedString); // Output: '1.000,00 €,2.000,00 €,3.000,00 €'\n        "
    },
    {
      "name": "toString",
      "trigger": "to string",
      "define": "The 'toString()' method returns a string representing the specified array and its elements. The elements are converted to strings using their 'toString()' methods and separated by commas. This method does not modify the original array.\n\nSyntax:\narray.toString()\n\nReturn Value:\nThe 'toString()' method returns a string representation of the array.\n\nExamples:\n1. Converting an array to a comma-separated string:\nlet fruits = ['apple', 'banana', 'orange'];\nlet fruitsString = fruits.toString();\nconsole.log(fruitsString); // Output: 'apple,banana,orange'\n\n2. Converting an array of numbers to a string:\nlet numbers = [1, 2, 3, 4, 5];\nlet numbersString = numbers.toString();\nconsole.log(numbersString); // Output: '1,2,3,4,5'\n",
      "example": "\n            // Example 1:\n            let fruits = ['apple', 'banana', 'orange'];\n            let fruitsString = fruits.toString();\n            console.log(fruitsString); // Output: 'apple,banana,orange'\n\n            // Example 2:\n            let numbers = [1, 2, 3, 4, 5];\n            let numbersString = numbers.toString();\n            console.log(numbersString); // Output: '1,2,3,4,5'\n        "
    },
    {
      "name": "unshift",
      "define": "The 'unshift()' method adds one or more elements to the beginning of an array and returns the new length of the array.\n\nSyntax:\narray.unshift(element1[, element2[, ...[, elementN]]])\n\nParameters:\n- 'element1', 'element2', ..., 'elementN' (required): The elements to add to the beginning of the array.\n\nReturn Value:\nThe 'unshift()' method returns the new length of the array after adding the specified elements.\n\nExamples:\n1. Adding elements to the beginning of an array:\nlet numbers = [3, 4, 5];\nlet newLength = numbers.unshift(1, 2);\nconsole.log(numbers); // Output: [1, 2, 3, 4, 5]\nconsole.log(newLength); // Output: 5\n\n2. Adding elements to an empty array:\nlet emptyArray = [];\nlet newLength = emptyArray.unshift('a', 'b', 'c');\nconsole.log(emptyArray); // Output: ['a', 'b', 'c']\nconsole.log(newLength); // Output: 3\n",
      "example": "\n            // Example 1:\n            let numbers = [3, 4, 5];\n            let newLength = numbers.unshift(1, 2);\n            console.log(numbers); // Output: [1, 2, 3, 4, 5]\n            console.log(newLength); // Output: 5\n\n            // Example 2:\n            let emptyArray = [];\n            let newLength = emptyArray.unshift('a', 'b', 'c');\n            console.log(emptyArray); // Output: ['a', 'b', 'c']\n            console.log(newLength); // Output: 3\n        "
    },
    {
      "name": "valueOf",
      "trigger": "value of",
      "define": "The 'valueOf()' method returns the primitive value of an array, which is the same as calling 'array.toString()'. This method is called automatically when an array is used in a context where a primitive value is expected, such as when an array is concatenated with a string.\n\nSyntax:\narray.valueOf()\n\nReturn Value:\nThe 'valueOf()' method returns a primitive value (a string) representing the array.\n\nExamples:\n1. Using 'valueOf()' to get the primitive value of an array:\nlet numbers = [1, 2, 3];\nlet primitiveValue = numbers.valueOf();\nconsole.log(primitiveValue); // Output: '1,2,3'\n\n2. Implicitly calling 'valueOf()' in a string context:\nlet fruits = ['apple', 'banana'];\nlet message = 'I like ' + fruits;\nconsole.log(message); // Output: 'I like apple,banana'\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3];\n            let primitiveValue = numbers.valueOf();\n            console.log(primitiveValue); // Output: '1,2,3'\n\n            // Example 2:\n            let fruits = ['apple', 'banana'];\n            let message = 'I like ' + fruits;\n            console.log(message); // Output: 'I like apple,banana'\n        "
    },
    {
      "name": "Set",
      "define": "The 'Set' object is a collection of unique values, meaning that each value can only occur once in the collection. It provides a simple way to create a list of distinct values, and it can store values of any data type, including objects.\n\nSyntax (Creating a Set):\nnew Set([iterable])\n\nParameters:\n- 'iterable' (optional): An iterable object (e.g., an array) whose elements will be added to the new Set. If not provided or 'null', an empty Set will be created.\n\nReturn Value:\nA new Set object containing the unique elements from the provided iterable.\n\nExamples:\n1. Creating a Set from an array:\nlet numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5];\nlet uniqueNumbers = new Set(numbers);\nconsole.log(uniqueNumbers); // Output: Set { 1, 2, 3, 4, 5 }\n\n2. Creating a Set with mixed data types:\nlet mixedData = [1, 'apple', { name: 'John' }, 'apple', { name: 'John' }, true, false];\nlet uniqueData = new Set(mixedData);\nconsole.log(uniqueData);\n// Output: Set { 1, 'apple', { name: 'John' }, true, false }\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5];\n            let uniqueNumbers = new Set(numbers);\n            console.log(uniqueNumbers); // Output: Set { 1, 2, 3, 4, 5 }\n\n            // Example 2:\n            let mixedData = [1, 'apple', { name: 'John' }, 'apple', { name: 'John' }, true, false];\n            let uniqueData = new Set(mixedData);\n            console.log(uniqueData);\n            // Output: Set { 1, 'apple', { name: 'John' }, true, false }\n        "
    },
    {
      "name": "WeakSet",
      "trigger": "weak set",
      "define": "The 'WeakSet' object is a collection of weakly held objects. Unlike 'Set', it can only contain objects, and these objects are held weakly, meaning they can be garbage-collected if there are no other strong references to them. It is often used to store a set of objects without preventing them from being garbage-collected.\n\nSyntax (Creating a WeakSet):\nnew WeakSet([iterable])\n\nParameters:\n- 'iterable' (optional): An iterable object (e.g., an array) whose elements (objects) will be added to the new WeakSet. If not provided or 'null', an empty WeakSet will be created.\n\nReturn Value:\nA new WeakSet object containing the elements (objects) from the provided iterable.\n\nNote: Due to weak references, there is no list of elements or method to loop over the elements of a WeakSet.\n\nExample:\n1. Creating a WeakSet with objects:\nlet john = { name: 'John' };\nlet jane = { name: 'Jane' };\nlet weakSet = new WeakSet([john, jane]);\nconsole.log(weakSet); // Output: WeakSet { [items unknown] }\n",
      "example": "\n            // Example 1:\n            let john = { name: 'John' };\n            let jane = { name: 'Jane' };\n            let weakSet = new WeakSet([john, jane]);\n            console.log(weakSet); // Output: WeakSet { [items unknown] }\n        "
    },
    {
      "name": "Map",
      "define": "The 'Map' object is a collection of key-value pairs where each key can occur only once in the Map. It provides a way to store and retrieve data based on keys and is often used to associate values with specific identifiers.\n\nSyntax (Creating a Map):\nnew Map([iterable])\n\nParameters:\n- 'iterable' (optional): An iterable object (e.g., an array) whose elements are key-value pairs (arrays with two elements) to be added to the new Map. If not provided or 'null', an empty Map will be created.\n\nReturn Value:\nA new Map object containing the key-value pairs from the provided iterable.\n\nExamples:\n1. Creating a Map from an array of key-value pairs:\nlet keyValuePairs = [['a', 1], ['b', 2], ['c', 3]];\nlet map = new Map(keyValuePairs);\nconsole.log(map);\n// Output: Map { 'a' => 1, 'b' => 2, 'c' => 3 }\n\n2. Creating a Map with various data types as keys and values:\nlet complexMap = new Map();\nlet objKey = { name: 'John' };\nlet funcKey = function () {};\nlet symKey = Symbol('key');\ncomplexMap.set(objKey, 'Value for object key');\ncomplexMap.set(funcKey, 'Value for function key');\ncomplexMap.set(symKey, 'Value for symbol key');\nconsole.log(complexMap);\n// Output: Map { { name: 'John' } => 'Value for object key', [Function (anonymous)] => 'Value for function key', Symbol(key) => 'Value for symbol key' }\n",
      "example": "\n            // Example 1:\n            let keyValuePairs = [['a', 1], ['b', 2], ['c', 3]];\n            let map = new Map(keyValuePairs);\n            console.log(map);\n            // Output: Map { 'a' => 1, 'b' => 2, 'c' => 3 }\n\n            // Example 2:\n            let complexMap = new Map();\n            let objKey = { name: 'John' };\n            let funcKey = function () {};\n            let symKey = Symbol('key');\n            complexMap.set(objKey, 'Value for object key');\n            complexMap.set(funcKey, 'Value for function key');\n            complexMap.set(symKey, 'Value for symbol key');\n            console.log(complexMap);\n            // Output: Map { { name: 'John' } => 'Value for object key', [Function (anonymous)] => 'Value for function key', Symbol(key) => 'Value for symbol key' }\n        "
    },
    {
      "name": "WeakMap",
      "trigger": "weak map",
      "define": "The 'WeakMap' object is a collection of weakly held key-value pairs, where keys must be objects. Similar to 'WeakSet', keys in a 'WeakMap' are held weakly, meaning they can be garbage-collected if there are no other strong references to them. It is often used to store private data associated with specific objects.\n\nSyntax (Creating a WeakMap):\nnew WeakMap([iterable])\n\nParameters:\n- 'iterable' (optional): An iterable object (e.g., an array) whose elements are key-value pairs (arrays with two elements) to be added to the new WeakMap. If not provided or 'null', an empty WeakMap will be created.\n\nReturn Value:\nA new WeakMap object containing the key-value pairs from the provided iterable.\n\nExample:\n1. Creating a WeakMap with objects as keys:\nlet john = { name: 'John' };\nlet jane = { name: 'Jane' };\nlet weakMap = new WeakMap([[john, 'John Doe'], [jane, 'Jane Doe']]);\nconsole.log(weakMap); // Output: WeakMap { [items unknown] }\n",
      "example": "\n            // Example 1:\n            let john = { name: 'John' };\n            let jane = { name: 'Jane' };\n            let weakMap = new WeakMap([[john, 'John Doe'], [jane, 'Jane Doe']]);\n            console.log(weakMap); // Output: WeakMap { [items unknown] }\n        "
    },
    {
      "name": "JSON",
      "define": "JSON (JavaScript Object Notation) is a lightweight data-interchange format used for data exchange between a server and a client, as well as for storing and transmitting structured data. It is based on a subset of the JavaScript language and is language-independent, meaning it can be used with most modern programming languages.\n\nIn JavaScript, the 'JSON' object provides methods for working with JSON data, including parsing JSON strings and converting JavaScript objects to JSON strings.\n\nExample (Parsing a JSON string):\nlet jsonString = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}';\nlet parsedObject = JSON.parse(jsonString);\nconsole.log(parsedObject);\n// Output: { name: 'John', age: 30, city: 'New York' }\n\nExample (Converting a JavaScript object to a JSON string):\nlet person = { name: 'Alice', age: 25, city: 'London' };\nlet jsonString = JSON.stringify(person);\nconsole.log(jsonString);\n// Output: '{\"name\":\"Alice\",\"age\":25,\"city\":\"London\"}'\n",
      "example": "\n            // Example (Parsing a JSON string):\n            let jsonString = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}';\n            let parsedObject = JSON.parse(jsonString);\n            console.log(parsedObject);\n            // Output: { name: 'John', age: 30, city: 'New York' }\n\n            // Example (Converting a JavaScript object to a JSON string):\n            let person = { name: 'Alice', age: 25, city: 'London' };\n            let jsonString = JSON.stringify(person);\n            console.log(jsonString);\n            // Output: '{\"name\":\"Alice\",\"age\":25,\"city\":\"London\"}'\n        "
    },
    {
      "name": "Promise",
      "define": "A 'Promise' is an object representing the eventual completion (or failure) of an asynchronous operation and its resulting value. It allows you to handle asynchronous operations more easily by chaining methods to handle success or failure. A Promise can be in one of three states: 'pending', 'fulfilled', or 'rejected'.\n\nSyntax (Creating a Promise):\nnew Promise(executor)\n\nParameters:\n- 'executor' (required): A function with two arguments, 'resolve' and 'reject'. It contains the asynchronous operation, which, when successful, calls 'resolve(value)' with the result value, and when it fails, calls 'reject(reason)' with an error or reason for the failure.\n\nExample:\n1. Creating and using a Promise to simulate an asynchronous operation:\nlet promise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        let randomNum = Math.random();\n        if (randomNum < 0.5) {\n            resolve(randomNum);\n        } else {\n            reject('Error: Random number is greater than or equal to 0.5');\n        }\n    }, 1000);\n});\n\npromise.then(\n    (result) => console.log('Fulfilled:', result),\n    (error) => console.log('Rejected:', error)\n);\n",
      "example": "\n            // Example 1:\n            let promise = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    let randomNum = Math.random();\n                    if (randomNum < 0.5) {\n                        resolve(randomNum);\n                    } else {\n                        reject('Error: Random number is greater than or equal to 0.5');\n                    }\n                }, 1000);\n            });\n\n            promise.then(\n                (result) => console.log('Fulfilled:', result),\n                (error) => console.log('Rejected:', error)\n            );\n        "
    },
    {
      "name": "async/await",
      "trigger": "await",
      "define": "'async/await' is a modern way of handling asynchronous operations in JavaScript. It allows you to write asynchronous code that looks more like synchronous code, making it easier to reason about and maintain.\n\nThe 'async' keyword is used to define an asynchronous function, and the 'await' keyword is used to pause the execution of the function until an asynchronous operation completes. When using 'await', the function will wait for the promise to resolve and then return the resolved value or throw an error if the promise is rejected.\n\nExample:\n1. Using 'async/await' to handle asynchronous operations:\nfunction fetchData() {\n    return new Promise((resolve) => {\n        setTimeout(() => resolve('Data received'), 2000);\n    });\n}\n\nasync function getData() {\n    try {\n        const result = await fetchData();\n        console.log(result);\n    } catch (error) {\n        console.log('Error:', error);\n    }\n}\n\ngetData();\n// Output (after 2 seconds): 'Data received'\n",
      "example": "\n            // Example 1:\n            function fetchData() {\n                return new Promise((resolve) => {\n                    setTimeout(() => resolve('Data received'), 2000);\n                });\n            }\n\n            async function getData() {\n                try {\n                    const result = await fetchData();\n                    console.log(result);\n                } catch (error) {\n                    console.log('Error:', error);\n                }\n            }\n\n            getData();\n            // Output (after 2 seconds): 'Data received'\n        "
    },
    {
      "name": "async/await",
      "trigger": "async",
      "define": "'async/await' is a modern way of handling asynchronous operations in JavaScript. It allows you to write asynchronous code that looks more like synchronous code, making it easier to reason about and maintain.\n\nThe 'async' keyword is used to define an asynchronous function, and the 'await' keyword is used to pause the execution of the function until an asynchronous operation completes. When using 'await', the function will wait for the promise to resolve and then return the resolved value or throw an error if the promise is rejected.\n\nExample:\n1. Using 'async/await' to handle asynchronous operations:\nfunction fetchData() {\n    return new Promise((resolve) => {\n        setTimeout(() => resolve('Data received'), 2000);\n    });\n}\n\nasync function getData() {\n    try {\n        const result = await fetchData();\n        console.log(result);\n    } catch (error) {\n        console.log('Error:', error);\n    }\n}\n\ngetData();\n// Output (after 2 seconds): 'Data received'\n",
      "example": "\n            // Example 1:\n            function fetchData() {\n                return new Promise((resolve) => {\n                    setTimeout(() => resolve('Data received'), 2000);\n                });\n            }\n\n            async function getData() {\n                try {\n                    const result = await fetchData();\n                    console.log(result);\n                } catch (error) {\n                    console.log('Error:', error);\n                }\n            }\n\n            getData();\n            // Output (after 2 seconds): 'Data received'\n        "
    },
    {
      "name": "try",
      "define": "'try/catch' is a control structure in JavaScript used for handling errors and exceptions in synchronous code. The 'try' block contains the code that might throw an error, and the 'catch' block handles the error if it occurs.\n\nIf an error is thrown within the 'try' block, the 'catch' block is executed, and the error object is passed as the argument to the 'catch' block.\n\nSyntax:\ntry {\n    // Code that might throw an error\n} catch (error) {\n    // Code to handle the error\n}\n\nExample:\n1. Using 'try/catch' to handle a potential error:\nfunction divideNumbers(a, b) {\n    try {\n        if (b === 0) {\n            throw new Error('Division by zero is not allowed.');\n        }\n        return a / b;\n    } catch (error) {\n        console.log('Error:', error.message);\n        return null;\n    }\n}\n\nlet result1 = divideNumbers(10, 2);\nconsole.log(result1); // Output: 5\n\nlet result2 = divideNumbers(8, 0);\nconsole.log(result2); // Output: null\n",
      "example": "\n            // Example 1:\n            function divideNumbers(a, b) {\n                try {\n                    if (b === 0) {\n                        throw new Error('Division by zero is not allowed.');\n                    }\n                    return a / b;\n                } catch (error) {\n                    console.log('Error:', error.message);\n                    return null;\n                }\n            }\n\n            let result1 = divideNumbers(10, 2);\n            console.log(result1); // Output: 5\n\n            let result2 = divideNumbers(8, 0);\n            console.log(result2); // Output: null\n        "
    },
    {
      "name": "catch",
      "define": "'try/catch' is a control structure in JavaScript used for handling errors and exceptions in synchronous code. The 'try' block contains the code that might throw an error, and the 'catch' block handles the error if it occurs.\n\nIf an error is thrown within the 'try' block, the 'catch' block is executed, and the error object is passed as the argument to the 'catch' block.\n\nSyntax:\ntry {\n    // Code that might throw an error\n} catch (error) {\n    // Code to handle the error\n}\n\nExample:\n1. Using 'try/catch' to handle a potential error:\nfunction divideNumbers(a, b) {\n    try {\n        if (b === 0) {\n            throw new Error('Division by zero is not allowed.');\n        }\n        return a / b;\n    } catch (error) {\n        console.log('Error:', error.message);\n        return null;\n    }\n}\n\nlet result1 = divideNumbers(10, 2);\nconsole.log(result1); // Output: 5\n\nlet result2 = divideNumbers(8, 0);\nconsole.log(result2); // Output: null\n",
      "example": "\n            // Example 1:\n            function divideNumbers(a, b) {\n                try {\n                    if (b === 0) {\n                        throw new Error('Division by zero is not allowed.');\n                    }\n                    return a / b;\n                } catch (error) {\n                    console.log('Error:', error.message);\n                    return null;\n                }\n            }\n\n            let result1 = divideNumbers(10, 2);\n            console.log(result1); // Output: 5\n\n            let result2 = divideNumbers(8, 0);\n            console.log(result2); // Output: null\n        "
    },
    {
      "name": "Error",
      "define": "'Error' is a built-in constructor function in JavaScript that creates an error object. When an error occurs during the execution of code, an 'Error' object is thrown with information about the error, including an error message and a stack trace.\n\nSyntax:\nnew Error([message])\n\nParameters:\n- 'message' (optional): A human-readable description of the error.\n\nExample:\n1. Creating and throwing a custom error:\nfunction doSomething() {\n    throw new Error('Something went wrong.');\n}\n\ntry {\n    doSomething();\n} catch (error) {\n    console.log('Error:', error.message);\n    console.log('Stack Trace:', error.stack);\n}\n",
      "example": "\n            // Example 1:\n            function doSomething() {\n                throw new Error('Something went wrong.');\n            }\n\n            try {\n                doSomething();\n            } catch (error) {\n                console.log('Error:', error.message);\n                console.log('Stack Trace:', error.stack);\n            }\n        "
    },
    {
      "name": "Error Types (e.g., TypeError, ReferenceError)",
      "trigger": "error types",
      "define": "In JavaScript, 'Error' is a base constructor, and there are several built-in error subclasses that inherit from it. These error subclasses are used to represent specific types of errors that can occur during program execution.\n\nCommon Error Types:\n1. 'TypeError': This error occurs when a value is not of the expected type. For example, calling a method on an undefined or null value may result in a 'TypeError'.\n\n2. 'ReferenceError': This error occurs when trying to access a variable or function that does not exist or is not in scope.\n\n3. 'SyntaxError': This error occurs when there is a syntax mistake in the code.\n\n4. 'RangeError': This error occurs when a value is not within the allowed range. For example, passing a negative value to 'Array.length' or using an invalid radix in 'parseInt' can result in a 'RangeError'.\n\n5. 'EvalError': This error is thrown when an error occurs during the execution of 'eval()' function.\n\n6. 'URIError': This error is thrown when there is a problem with the URI (Uniform Resource Identifier) handling functions.\n\nExample:\n1. Using 'try/catch' to handle different error types:\nfunction divideNumbers(a, b) {\n    try {\n        if (b === 0) {\n            throw new Error('Division by zero is not allowed.');\n        }\n        return a / b;\n    } catch (error) {\n        if (error instanceof TypeError) {\n            console.log('TypeError:', error.message);\n        } else if (error instanceof ReferenceError) {\n            console.log('ReferenceError:', error.message);\n        } else if (error instanceof RangeError) {\n            console.log('RangeError:', error.message);\n        } else {\n            console.log('Error:', error.message);\n        }\n        return null;\n    }\n}\n",
      "example": "\n            // Example 1:\n            function divideNumbers(a, b) {\n                try {\n                    if (b === 0) {\n                        throw new Error('Division by zero is not allowed.');\n                    }\n                    return a / b;\n                } catch (error) {\n                    if (error instanceof TypeError) {\n                        console.log('TypeError:', error.message);\n                    } else if (error instanceof ReferenceError) {\n                        console.log('ReferenceError:', error.message);\n                    } else if (error instanceof RangeError) {\n                        console.log('RangeError:', error.message);\n                    } else {\n                        console.log('Error:', error.message);\n                    }\n                    return null;\n                }\n            }\n        "
    },
    {
      "name": "finally",
      "define": "'finally' is a block that follows the 'try' and 'catch' blocks in a 'try/catch/finally' statement. It contains code that will be executed regardless of whether an error occurs or not. The 'finally' block is commonly used to perform cleanup actions, such as releasing resources or closing connections.\n\nSyntax:\ntry {\n    // Code that might throw an error\n} catch (error) {\n    // Code to handle the error\n} finally {\n    // Code that will be executed regardless of whether there was an error or not\n}\n\nExample:\n1. Using 'finally' to ensure resource cleanup:\nfunction fetchData() {\n    let resource = acquireResource();\n\n    try {\n        // Use the resource to fetch data\n        return data;\n    } catch (error) {\n        // Handle the error\n    } finally {\n        // Always release the resource, even if there was an error\n        releaseResource(resource);\n    }\n}\n",
      "example": "\n            // Example 1:\n            function fetchData() {\n                let resource = acquireResource();\n\n                try {\n                    // Use the resource to fetch data\n                    return data;\n                } catch (error) {\n                    // Handle the error\n                } finally {\n                    // Always release the resource, even if there was an error\n                    releaseResource(resource);\n                }\n            }\n        "
    },
    {
      "name": "Event",
      "define": "In the context of web development, an 'Event' is an occurrence triggered by a user action or by the browser itself. Events can be related to user interactions (e.g., clicking a button) or to changes in the state of the browser or the web page (e.g., page loading, resizing).\n\nJavaScript provides mechanisms to handle events and attach event listeners to elements. Event listeners are functions that are executed when a specific event occurs.\n\nExamples of Common Events:\n1. 'click': Triggered when a mouse click occurs on an element.\n2. 'keydown': Triggered when a keyboard key is pressed.\n3. 'mouseover': Triggered when the mouse pointer moves over an element.\n4. 'submit': Triggered when a form is submitted.\n5. 'load': Triggered when a web page or an external resource finishes loading.\n6. 'resize': Triggered when the browser window is resized.\n\nExample (Adding an event listener for a button click):\nHTML:\n<button id=\"myButton\">Click Me</button>\n\nJavaScript:\ndocument.getElementById('myButton').addEventListener('click', function() {\n    alert('Button clicked!');\n});\n",
      "example": "\n            // Example 1:\n            HTML:\n            <button id=\"myButton\">Click Me</button>\n\n            JavaScript:\n            document.getElementById('myButton').addEventListener('click', function() {\n                alert('Button clicked!');\n            });\n        "
    },
    {
      "name": "addEventListener",
      "trigger": "add event",
      "define": "'addEventListener' is a method used to attach an event listener to an element in the DOM (Document Object Model). It allows you to specify a function that should be executed when a specific event is triggered on the element.\n\nSyntax:\nelement.addEventListener(event, listenerFunction, options);\n\nParameters:\n- 'event' (required): A string that specifies the name of the event to listen for (e.g., 'click', 'keydown', 'mouseover', etc.).\n- 'listenerFunction' (required): The function that will be executed when the specified event occurs.\n- 'options' (optional): An object that specifies additional options for the event listener, such as 'once' (true/false) to indicate if the listener should only be triggered once.\n\nExample:\n1. Adding an event listener for a button click:\nHTML:\n<button id=\"myButton\">Click Me</button>\n\nJavaScript:\nfunction handleClick() {\n    alert('Button clicked!');\n}\n\ndocument.getElementById('myButton').addEventListener('click', handleClick);\n",
      "example": "\n            // Example 1:\n            HTML:\n            <button id=\"myButton\">Click Me</button>\n\n            JavaScript:\n            function handleClick() {\n                alert('Button clicked!');\n            }\n\n            document.getElementById('myButton').addEventListener('click', handleClick);\n        "
    },
    {
      "name": "removeEventListener",
      "trigger": "remove event",
      "define": "'removeEventListener' is a method used to remove an event listener that was previously attached to an element with 'addEventListener()'. This method is essential for cleaning up event listeners to prevent memory leaks.\n\nSyntax:\nelement.removeEventListener(event, listenerFunction);\n\nParameters:\n- 'event' (required): A string that specifies the name of the event for which the listener was registered.\n- 'listenerFunction' (required): The function that was previously attached as the event listener.\n\nExample:\n1. Removing an event listener for a button click:\nHTML:\n<button id=\"myButton\">Click Me</button>\n\nJavaScript:\nfunction handleClick() {\n    alert('Button clicked!');\n}\n\nlet button = document.getElementById('myButton');\nbutton.addEventListener('click', handleClick);\n\n// After some time, remove the event listener\nbutton.removeEventListener('click', handleClick);\n",
      "example": "\n            // Example 1:\n            HTML:\n            <button id=\"myButton\">Click Me</button>\n\n            JavaScript:\n            function handleClick() {\n                alert('Button clicked!');\n            }\n\n            let button = document.getElementById('myButton');\n            button.addEventListener('click', handleClick);\n\n            // After some time, remove the event listener\n            button.removeEventListener('click', handleClick);\n        "
    },
    {
      "name": "Propagation (Event Bubbling and Capturing)",
      "trigger": "propagation",
      "define": "Event propagation refers to the way events are handled when an element's event triggers on nested elements. There are two main types of event propagation in the DOM: event bubbling and event capturing.\n\n1. Event Bubbling:\n   - When an event occurs on an element, it triggers the event on itself first, then on its parent element, and so on up to the root of the document.\n   - Most events bubble by default, and you can use 'event.stopPropagation()' inside an event listener to stop the event from further propagating.\n\n2. Event Capturing (or Event Trickling):\n   - Event capturing is the opposite of event bubbling. The event is triggered on the root element first and then propagates down the DOM hierarchy to the target element.\n\nExample:\n1. Event Bubbling and Capturing:\nHTML:\n<div id=\"outer\">\n    <div id=\"inner\">\n        <button id=\"myButton\">Click Me</button>\n    </div>\n</div>\n\nJavaScript:\nfunction handleClick(event) {\n    console.log('Target:', event.target.id);\n    console.log('Current Target:', event.currentTarget.id);\n}\n\nlet button = document.getElementById('myButton');\nlet inner = document.getElementById('inner');\nlet outer = document.getElementById('outer');\n\nbutton.addEventListener('click', handleClick);\ninner.addEventListener('click', handleClick, true); // Use 'true' for event capturing\nouter.addEventListener('click', handleClick, true);\n",
      "example": "\n            // Example 1:\n            HTML:\n            <div id=\"outer\">\n                <div id=\"inner\">\n                    <button id=\"myButton\">Click Me</button>\n                </div>\n            </div>\n\n            JavaScript:\n            function handleClick(event) {\n                console.log('Target:', event.target.id);\n                console.log('Current Target:', event.currentTarget.id);\n            }\n\n            let button = document.getElementById('myButton');\n            let inner = document.getElementById('inner');\n            let outer = document.getElementById('outer');\n\n            button.addEventListener('click', handleClick);\n            inner.addEventListener('click', handleClick, true); // Use 'true' for event capturing\n            outer.addEventListener('click', handleClick, true);\n        "
    },
    {
      "name": "localStorage",
      "trigger": "local storage",
      "define": "'localStorage' is a feature in modern web browsers that allows you to store key-value pairs locally in the user's browser. It provides a simple way to persistently store data, such as user preferences, settings, or small amounts of data, even when the user closes the browser or navigates away from the page.\n\nData stored in 'localStorage' is available across sessions, meaning the data will persist even after the browser is closed and reopened.\n\nExample (Storing and retrieving data in 'localStorage'):\n// Storing data in 'localStorage'\nlocalStorage.setItem('username', 'JohnDoe');\nlocalStorage.setItem('theme', 'dark');\n\n// Retrieving data from 'localStorage'\nlet username = localStorage.getItem('username');\nlet theme = localStorage.getItem('theme');\n\nconsole.log(username); // Output: 'JohnDoe'\nconsole.log(theme);    // Output: 'dark'\n",
      "example": "\n            // Example 1:\n            // Storing data in 'localStorage'\n            localStorage.setItem('username', 'JohnDoe');\n            localStorage.setItem('theme', 'dark');\n\n            // Retrieving data from 'localStorage'\n            let username = localStorage.getItem('username');\n            let theme = localStorage.getItem('theme');\n\n            console.log(username); // Output: 'JohnDoe'\n            console.log(theme);    // Output: 'dark'\n        "
    },
    {
      "name": "sessionStorage",
      "trigger": "session storage",
      "define": "'sessionStorage' is similar to 'localStorage', but the data stored in 'sessionStorage' is only available within the current browser session. Once the user closes the browser or tab, the data is cleared, and it won't persist across sessions.\n\nExample (Storing and retrieving data in 'sessionStorage'):\n// Storing data in 'sessionStorage'\nsessionStorage.setItem('city', 'New York');\nsessionStorage.setItem('language', 'English');\n\n// Retrieving data from 'sessionStorage'\nlet city = sessionStorage.getItem('city');\nlet language = sessionStorage.getItem('language');\n\nconsole.log(city);     // Output: 'New York'\nconsole.log(language); // Output: 'English'\n",
      "example": "\n            // Example 1:\n            // Storing data in 'sessionStorage'\n            sessionStorage.setItem('city', 'New York');\n            sessionStorage.setItem('language', 'English');\n\n            // Retrieving data from 'sessionStorage'\n            let city = sessionStorage.getItem('city');\n            let language = sessionStorage.getItem('language');\n\n            console.log(city);     // Output: 'New York'\n            console.log(language); // Output: 'English'\n        "
    },
    {
      "name": "IndexedDB",
      "trigger": "indexed db",
      "define": "'IndexedDB' is a low-level API for client-side storage of significant amounts of structured data. Unlike 'localStorage' and 'sessionStorage', which store data in a simple key-value format, IndexedDB allows you to store complex data structures, query data using indexes, and work with large datasets efficiently.\n\nIndexedDB is commonly used in web applications that require offline support or need to store large amounts of data locally.\n\nExample (Creating an IndexedDB database and adding data):\n// Open a database (if it doesn't exist, it will be created)\nlet request = indexedDB.open('myDatabase', 1);\n\n// Event listener for successful database creation or upgrade\nrequest.onsuccess = function(event) {\n    let db = event.target.result;\n\n    // Create a transaction and access the object store\n    let transaction = db.transaction(['customers'], 'readwrite');\n    let objectStore = transaction.objectStore('customers');\n\n    // Add data to the object store\n    let customer = { id: 1, name: 'John Doe', email: 'john@example.com' };\n    objectStore.add(customer);\n\n    console.log('Data added to the object store.');\n};\n\n// Event listener for database error\nrequest.onerror = function(event) {\n    console.log('Error:', event.target.errorCode);\n};\n",
      "example": "\n            // Example 1:\n            // Open a database (if it doesn't exist, it will be created)\n            let request = indexedDB.open('myDatabase', 1);\n\n            // Event listener for successful database creation or upgrade\n            request.onsuccess = function(event) {\n                let db = event.target.result;\n\n                // Create a transaction and access the object store\n                let transaction = db.transaction(['customers'], 'readwrite');\n                let objectStore = transaction.objectStore('customers');\n\n                // Add data to the object store\n                let customer = { id: 1, name: 'John Doe', email: 'john@example.com' };\n                objectStore.add(customer);\n\n                console.log('Data added to the object store.');\n            };\n\n            // Event listener for database error\n            request.onerror = function(event) {\n                console.log('Error:', event.target.errorCode);\n            };\n        "
    },
    {
      "name": "fetch",
      "define": "The Fetch API is a modern JavaScript API used to make asynchronous network requests. It provides a more flexible and powerful alternative to traditional XMLHttpRequest. The Fetch API uses Promises to handle the responses, making it easier to write asynchronous code and avoiding callback hell.\n\nThe basic usage of the Fetch API involves calling the global 'fetch' function with the URL of the resource you want to fetch. This function returns a Promise that resolves to the Response object representing the response to the request. You can then use methods like 'json()', 'text()', 'blob()', etc., on the Response object to extract the data from the response.\n\nKeep in mind that the Fetch API only rejects the Promise on network errors, not HTTP errors like 404 or 500. You need to check the 'ok' property of the Response object to verify if the request was successful or not.",
      "example": "\n            \"Basic GET request using Fetch API:\"\n            fetch('https://api.example.com/data')\n                .then(response => response.json())\n                .then(data => console.log(data))\n                .catch(error => console.error(error));\n\n            \"POST request with headers using Fetch API:\"\n            fetch('https://api.example.com/data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    key: 'value',\n                })\n            })\n                .then(response => response.json())\n                .then(data => console.log(data))\n                .catch(error => console.error(error));\"\n        "
    },
    {
      "name": "function",
      "define": "In JavaScript, a function is a reusable block of code that performs a specific task or calculates a value. Functions allow you to divide your code into smaller, manageable pieces, promoting code reusability and maintainability.\n\nThere are several ways to define functions in JavaScript:\n1. Function Declaration:\n    function greet() {\n        console.log('Hello, world!');\n    }\n\n2. Function Expression (Anonymous Function):\n    const greet = function() {\n        console.log('Hello, world!');\n    };\n\n3. Arrow Function (Introduced in ES6):\n    const greet = () => {\n        console.log('Hello, world!');\n    };\n\nFunctions can take parameters (input values) and return a value using the 'return' keyword. If a function doesn't explicitly return a value, it will return 'undefined' by default.\n\nExamples of functions with parameters and return values:\nfunction addNumbers(a, b) {\n    return a + b;\n}\nconsole.log(addNumbers(3, 5)); // Output: 8\n\nfunction calculateCircleArea(radius) {\n    return Math.PI * radius * radius;\n}\nconsole.log(calculateCircleArea(5)); // Output: 78.53981633974483\n",
      "example": ""
    },
    {
      "name": "generator",
      "define": "Generators are special functions in JavaScript that can be paused and resumed during execution. They use the 'yield' keyword to produce a sequence of values, which can be iterated. Generators provide an elegant way to create iterators and are particularly useful for handling asynchronous operations.\n\nTo define a generator function, you use an asterisk (*) after the 'function' keyword. When you call a generator function, it doesn't execute the code immediately; instead, it returns an iterator object.\n\nExamples of generator functions:\nfunction* numberGenerator() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\nconst gen = numberGenerator();\nconsole.log(gen.next().value); // Output: 1\nconsole.log(gen.next().value); // Output: 2\nconsole.log(gen.next().value); // Output: 3\n\nfunction* fibonacciGenerator() {\n    let [prev, curr] = [0, 1];\n    while (true) {\n        yield curr;\n        [prev, curr] = [curr, prev + curr];\n    }\n}\nconst fibGen = fibonacciGenerator();\nconsole.log(fibGen.next().value); // Output: 1\nconsole.log(fibGen.next().value); // Output: 1\nconsole.log(fibGen.next().value); // Output: 2\n",
      "example": ""
    },
    {
      "name": "hoisting",
      "define": "Hoisting is a JavaScript behavior where variable declarations and function declarations are moved to the top of their containing scope during the compilation phase. However, only the declarations are hoisted, not the initializations.\n\nHoisting applies to both variables declared with 'var' and functions declared using the 'function' keyword. Variables declared with 'let', 'const', or 'class' are not hoisted.\n\nExample of variable hoisting:\nconsole.log(x); // Output: undefined\nvar x = 5;\nconsole.log(x); // Output: 5\n\nExample of function hoisting:\nfoo(); // Output: 'Hello'\nfunction foo() {\n    console.log('Hello');\n}\n",
      "example": ""
    },
    {
      "name": "iife (immediately invoked function expression)",
      "trigger": "immediately invoked",
      "define": "An IIFE (Immediately Invoked Function Expression) is a function in JavaScript that is executed immediately after its creation. It helps create a private scope and avoid polluting the global namespace.\n\nThe syntax of an IIFE involves wrapping the function in parentheses and then immediately invoking it using an additional pair of parentheses.\n\nIIFE is commonly used to create modules, avoid variable hoisting issues, and isolate code from the global scope.\n\nExamples of IIFE:\n(function() {\n    console.log('IIFE executed!');\n})(); // Output: 'IIFE executed!'\n\n(function(name) {\n    console.log('Hello, ' + name + '!');\n})('John'); // Output: 'Hello, John!'\n",
      "example": ""
    },
    {
      "name": "immutable",
      "define": "Immutable.js is a library for JavaScript that provides immutable data structures. It ensures that the data remains unchanged after creation, making it easier to manage application state and prevent unintended modifications.\n\nImmutable.js offers several data structures like List, Map, Set, etc., that cannot be modified directly. Instead, methods such as 'push()', 'pop()', 'set()', etc., return new instances with the modified data.\n\nExample of creating an immutable list:\nconst { List } = require('immutable');\nconst list = List([1, 2, 3]);\n\nExample of modifying an immutable list:\nconst newList = list.push(4);\nconsole.log(list.size); // Output: 3\nconsole.log(newList.size); // Output: 4\n",
      "example": ""
    },
    {
      "name": "iteration",
      "define": "Iteration refers to the process of repeatedly executing a block of code for each element in a collection, such as an array or an object. It allows you to perform the same operation on each item in the collection.\n\nIn JavaScript, there are several ways to iterate over collections:\n1. for Loop: The traditional 'for' loop is commonly used for iterating over arrays and performing actions on each element.\n\nExample of using 'for' loop for array iteration:\nconst arr = [1, 2, 3];\nfor (let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}\n\n2. forEach() Method: The 'forEach()' method is available on arrays and provides a more concise way to iterate over array elements.\n\nExample of using 'forEach()' method for array iteration:\narr.forEach(item => console.log(item));\n\n3. for...of Loop: Introduced in ES6, the 'for...of' loop provides a convenient way to iterate over iterable objects, including arrays, strings, maps, sets, etc.\n\nExample of using 'for...of' loop for array iteration:\nfor (const item of arr) {\n    console.log(item);\n}\n\n4. for...in Loop: The 'for...in' loop is used to iterate over the properties of an object. However, it is not recommended for iterating over arrays due to potential issues with the iteration order and non-numeric keys.\n\nExample of using 'for...in' loop for object iteration:\nconst obj = { name: 'John', age: 30 };\nfor (const key in obj) {\n    console.log(key + ': ' + obj[key]);\n}\n\nIt's important to choose the appropriate iteration method depending on the type of collection you are working with to ensure efficient and correct iteration of elements.\n",
      "example": ""
    },
    {
      "name": "jest",
      "define": "Jest is a popular JavaScript testing framework that is widely used for testing applications, particularly React applications. It provides a simple and efficient way to write unit tests and perform various testing tasks.\n\nJest is designed to be easy to set up and use. It comes with built-in support for mocking, assertions, and code coverage reporting. Jest runs tests in parallel, which helps to speed up the testing process.\n\nSome key features of Jest include:\n- Zero Configuration: Jest requires minimal setup and can run tests without the need for a separate configuration file, making it beginner-friendly.\n- Mocking: Jest provides powerful mocking capabilities, allowing you to simulate the behavior of external dependencies and focus on testing individual units in isolation.\n- Snapshot Testing: Snapshot testing allows you to capture the rendered output of components and compare it against the expected output, making it easier to detect unexpected changes.\n- Asynchronous Testing: Jest simplifies testing asynchronous code using methods like 'async/await', 'Promise.resolve', and 'Promise.reject'.\n- Code Coverage: Jest generates code coverage reports, enabling you to identify areas of code that are not adequately covered by tests.\n\nExample of a basic test with Jest:\nfunction add(a, b) {\n    return a + b;\n}\ntest('adds 1 + 2 to equal 3', () => {\n    expect(add(1, 2)).toBe(3);\n});\n\nExample of testing asynchronous code with Jest (using async/await):\nfunction fetchData() {\n    return new Promise(resolve => resolve('data'));\n}\ntest('fetchData returns data', async () => {\n    const data = await fetchData();\n    expect(data).toBe('data');\n});\n",
      "example": ""
    },
    {
      "name": "jquery",
      "define": "jQuery is a fast, small, and feature-rich JavaScript library. It simplifies HTML document traversal and manipulation, event handling, animation, and Ajax interactions.\n\njQuery allows you to write concise and efficient code to perform common tasks. It abstracts many of the complexities of JavaScript and provides a consistent and easy-to-use API.\n\nSome key features of jQuery include:\n- DOM Manipulation: jQuery provides a set of methods to select and manipulate HTML elements, making it easier to add, remove, or modify content on a web page.\n- Event Handling: jQuery simplifies event handling by providing methods to attach event listeners to elements, such as 'click', 'mouseover', 'keyup', etc.\n- Ajax: jQuery makes Ajax interactions more accessible with methods like '$.ajax()', '$.get()', and '$.post()', allowing you to load data from a server without a full page refresh.\n- Animation: jQuery provides a wide range of animation effects, such as fading, sliding, and toggling elements, making it easier to create interactive and visually appealing web pages.\n- Plugin Support: jQuery has a vibrant community that creates plugins, extending its functionality and providing solutions for various common tasks.\n\nExample of basic DOM manipulation with jQuery:\n<div id='myDiv'>Hello</div>\n<script src='jquery.min.js'></script>\n<script>\n    // Change the content of the div\n    $('#myDiv').text('Hello, world!');\n</script>\n\nExample of Ajax request with jQuery:\nfunction fetchData() {\n    $.ajax({\n        url: 'https://api.example.com/data',\n        success: function(data) {\n            console.log(data);\n        },\n        error: function(error) {\n            console.error(error);\n        }\n    });\n}\nfetchData();\n",
      "example": ""
    },
    {
      "name": "json",
      "define": "JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write, and easy for machines to parse and generate. It is widely used for data serialization and communication between web clients and servers.\n\nJSON data consists of key-value pairs, where keys are strings enclosed in double quotes, and values can be strings, numbers, booleans, arrays, or other JSON objects. JSON does not support functions or undefined values.\n\nExample of a JSON object:\n{\n    \"name\": \"John Doe\",\n    \"age\": 30,\n    \"isEmployed\": true,\n    \"hobbies\": [\"reading\", \"traveling\", \"photography\"],\n    \"address\": {\n        \"city\": \"New York\",\n        \"zipCode\": \"10001\"\n    }\n}\n\nJSON.stringify(): The 'JSON.stringify()' method is used to convert a JavaScript object or value to a JSON string.\n\nExample of using JSON.stringify():\nconst data = {\n    name: 'John Doe',\n    age: 30,\n    isEmployed: true\n};\nconst jsonString = JSON.stringify(data);\nconsole.log(jsonString); // Output: '{\"name\":\"John Doe\",\"age\":30,\"isEmployed\":true}'\n\nJSON.parse(): The 'JSON.parse()' method is used to convert a JSON string back into a JavaScript object.\n\nExample of using JSON.parse():\nconst jsonString = '{\"name\":\"John Doe\",\"age\":30,\"isEmployed\":true}';\nconst data = JSON.parse(jsonString);\nconsole.log(data.name); // Output: 'John Doe'\n",
      "example": ""
    },
    {
      "name": "let",
      "define": "'let' is a keyword introduced in ECMAScript 6 (ES6) for declaring block-scoped variables in JavaScript. Variables declared with 'let' are similar to 'var' but have some key differences:\n\n1. Block Scope: Variables declared with 'let' have block scope, which means they are only accessible within the block (a pair of curly braces) where they are defined. This behavior prevents variable hoisting issues that can occur with 'var'.\n\nExample of block-scoped 'let' variable:\nif (true) {\n    let x = 10;\n}\nconsole.log(x); // Error: 'x' is not defined\n\n2. Hoisting: While 'let' variables are hoisted like 'var', they are not initialized until the point of declaration. This is known as the \"temporal dead zone,\" and accessing the variable before its declaration results in a ReferenceError.\n\nExample of temporal dead zone with 'let':\nconsole.log(x); // Error: Cannot access 'x' before initialization\nlet x = 10;\n\n3. Redeclaration: Unlike 'var', you cannot redeclare the same variable within the same block scope using 'let'. Attempting to do so will result in a SyntaxError.\n\nExample of redeclaration error with 'let':\nlet x = 10;\nlet x = 20; // Error: Identifier 'x' has already been declared\n\n4. Global Object Property: When using 'let' at the top level of a script (outside of any function or block), the variable is not added as a property of the global object (e.g., 'window' in browsers), unlike 'var'.\n\nExample of global object property with 'var':\nvar y = 5;\nconsole.log(window.y); // Output: 5\n\nExample of no global object property with 'let':\nlet z = 8;\nconsole.log(window.z); // Output: undefined\n",
      "example": ""
    },
    {
      "name": "lodash",
      "trigger": "low dash",
      "define": "Lodash is a popular JavaScript utility library that provides a wide range of helper functions for working with arrays, objects, strings, functions, and more. It offers a consistent and efficient API, making it easier to perform common tasks and solve complex problems in a more functional and declarative style.\n\nLodash functions are carefully optimized for performance and are widely used in various JavaScript projects. By using Lodash, you can reduce the amount of custom code you need to write and avoid reinventing the wheel.\n\nSome key features of Lodash include:\n1. Collection Manipulation: Lodash provides functions for working with arrays and objects, such as 'map()', 'filter()', 'reduce()', 'find()', 'groupBy()', and many others.\n2. String Manipulation: Lodash offers utilities for string operations, including 'trim()', 'startsWith()', 'endsWith()', 'camelCase()', 'kebabCase()', and more.\n3. Functional Programming: Lodash includes functions that enable functional programming paradigms, like 'curry()', 'partial()', 'debounce()', 'throttle()', and 'memoize()'.\n4. Chaining: Lodash supports method chaining, allowing you to perform multiple operations in a single expression for a more concise and readable code.\n\nExample of using Lodash to work with arrays:\nconst _ = require('lodash');\n\nconst numbers = [1, 2, 3, 4, 5];\n\n// Using Lodash to get the sum of squared even numbers\nconst sumOfSquaredEvenNumbers = _.chain(numbers)\n    .filter(num => num % 2 === 0)\n    .map(num => num * num)\n    .sum()\n    .value();\n\nconsole.log(sumOfSquaredEvenNumbers); // Output: 20\n",
      "example": ""
    },
    {
      "name": "map",
      "define": "In JavaScript, 'map' is a higher-order function that is used to transform elements of an array into a new array based on a provided mapping function. The 'map' function does not modify the original array; instead, it creates a new array with the same length as the original, containing the results of applying the mapping function to each element.\n\nSyntax of 'map':\narray.map((currentValue, index, array) => {\n    // Return the new value for the element\n});\n\nParameters:\n- 'currentValue' (required): The current element being processed in the array.\n- 'index' (optional): The index of the current element in the array.\n- 'array' (optional): The array being processed.\n\nReturn Value:\nThe 'map' function returns a new array containing the values returned by the mapping function for each element of the original array.\n\nExample of using 'map' to transform an array:\nlet numbers = [1, 2, 3, 4, 5];\n\nlet squaredNumbers = numbers.map((num) => {\n    return num * num;\n});\n\nconsole.log(squaredNumbers); // Output: [1, 4, 9, 16, 25]\n\nIn this example, 'map' is used to create a new array 'squaredNumbers' where each element is the square of the corresponding element in the 'numbers' array.\n\nUsing Arrow Function Shorthand:\nSince 'map' often involves simple transformations, it is common to use the arrow function shorthand for concise code.\n\nExample of using arrow function shorthand with 'map':\nlet numbers = [1, 2, 3, 4, 5];\n\nlet squaredNumbers = numbers.map(num => num * num);\n\nconsole.log(squaredNumbers); // Output: [1, 4, 9, 16, 25]\n\nMapping Objects:\nThe 'map' function can also be used to transform objects into new objects by manipulating their properties.\n\nExample of using 'map' to transform an array of objects:\nlet persons = [\n    { name: 'John', age: 30 },\n    { name: 'Alice', age: 25 },\n    { name: 'Bob', age: 35 }\n];\n\nlet greetings = persons.map((person) => {\n    return 'Hello, ' + person.name + '!';\n});\n\nconsole.log(greetings);\n// Output: [\"Hello, John!\", \"Hello, Alice!\", \"Hello, Bob!\"]\n\nIn this example, 'map' is used to create a new array 'greetings' where each element is a greeting message based on the 'name' property of each object in the 'persons' array.\n\nMapping Undefined or Sparse Elements:\nIf some elements of the original array are 'undefined', 'map' skips those elements during the transformation.\n\nExample of mapping undefined elements:\nlet numbers = [1, 2, , 4, 5]; // The third element is undefined\n\nlet doubledNumbers = numbers.map((num) => {\n    return num * 2;\n});\n\nconsole.log(doubledNumbers); // Output: [2, 4, NaN, 8, 10]\n\nIn this example, the third element (undefined) is skipped during the mapping, resulting in 'NaN' (Not a Number) in the 'doubledNumbers' array.\n\nThe 'map' function is a powerful tool for data manipulation and transformation in JavaScript, enabling developers to efficiently process arrays and create new arrays based on specific criteria or operations.",
      "example": "\n            // Example of using 'map' to transform an array\n            let numbers = [1, 2, 3, 4, 5];\n\n            let doubledNumbers = numbers.map((num) => {\n                return num * 2;\n            });\n\n            console.log(doubledNumbers); // Output: [2, 4, 6, 8, 10]\n        "
    },
    {
      "name": "mocha",
      "define": "Mocha is a feature-rich JavaScript testing framework for running both synchronous and asynchronous tests. It is often used for testing Node.js applications and server-side code. Mocha provides an easy-to-read and flexible testing syntax, making it popular among developers for writing unit tests, integration tests, and more.\n\nKey features of Mocha include:\n1. Test Suite: Mocha allows you to organize tests into test suites using the 'describe()' function, which makes test results more structured and easier to understand.\n2. Test Cases: Each individual test is represented as a test case, created using the 'it()' function. You can use assertions inside test cases to validate expected outcomes.\n3. Asynchronous Testing: Mocha supports asynchronous testing using callback functions, Promises, or 'async/await' syntax, making it easy to handle asynchronous operations during testing.\n4. Hooks: Mocha provides hooks like 'before()', 'after()', 'beforeEach()', and 'afterEach()', which allow you to run setup and cleanup code before and after test cases or test suites.\n5. Support for Various Reporters: Mocha supports different reporters to display test results in various formats, including the built-in 'spec' reporter, 'nyan' reporter, 'dot' reporter, and more.\n6. Integration with Other Libraries: Mocha integrates well with assertion libraries like 'Chai', allowing you to choose the assertion style that suits your preferences.\n\nExample of a basic Mocha test:\nconst assert = require('assert');\n\nfunction add(a, b) {\n    return a + b;\n}\n\ndescribe('add() function', () => {\n    it('should return the sum of two numbers', () => {\n        const result = add(2, 3);\n        assert.strictEqual(result, 5);\n    });\n});\n",
      "example": ""
    },
    {
      "name": "module",
      "define": "In JavaScript, a module refers to a self-contained unit of code that can be exported, imported, and reused in other parts of the application. Modules help organize code and promote code encapsulation and reusability.\n\nPrior to ES6 (ECMAScript 2015), JavaScript did not have native support for modules. Developers relied on various module patterns like the Revealing Module Pattern and CommonJS to achieve modularity.\n\nWith the introduction of ES6 modules, JavaScript officially supports a standardized way to create, import, and export modules. ES6 modules use the 'export' and 'import' keywords to control what gets exposed from a module and what gets imported into another module.\n\nExample of exporting and importing modules in ES6:\n// math.js (module)\nexport function add(a, b) {\n    return a + b;\n}\n\n// app.js (module)\nimport { add } from './math.js';\n\nconsole.log(add(2, 3)); // Output: 5\n\nIn Node.js, modules are also an essential part of the ecosystem, and CommonJS is the standard module format used. Node.js modules use 'module.exports' and 'require()' to export and import modules, respectively.\n\nExample of exporting and importing modules in Node.js:\n// math.js (module)\nfunction add(a, b) {\n    return a + b;\n}\nmodule.exports = { add };\n\n// app.js (module)\nconst { add } = require('./math.js');\n\nconsole.log(add(2, 3)); // Output: 5\n\nUsing modules, developers can break down complex applications into smaller, manageable pieces, making it easier to maintain and collaborate with other team members.\n",
      "example": ""
    },
    {
      "name": "nan",
      "define": "NaN (Not-a-Number) is a special value in JavaScript that represents an unrepresentable or undefined numerical result. It is returned when a mathematical operation or function fails to produce a meaningful numeric result.\n\nNaN is a property of the global object and can be accessed using 'window.NaN' in browsers or 'global.NaN' in Node.js.\n\nExamples of operations that result in NaN:\nconsole.log(0 / 0); // Output: NaN\nconsole.log(Math.sqrt(-1)); // Output: NaN\n\nNaN is unique because it does not equal anything, including itself. To test if a value is NaN, you need to use the 'isNaN()' function or the global 'Number.isNaN()' method introduced in ES6.\n\nExamples of checking for NaN:\nconsole.log(isNaN(NaN)); // Output: true\nconsole.log(Number.isNaN(NaN)); // Output: true\n\nNote that 'isNaN()' returns true for any non-numeric value, so it's recommended to use 'Number.isNaN()' when specifically checking for NaN.\n",
      "example": ""
    },
    {
      "name": "node",
      "define": "Node.js is a server-side JavaScript runtime that allows developers to run JavaScript code outside of a web browser. It uses the V8 JavaScript engine, the same engine that powers Google Chrome, to execute JavaScript code on the server.\n\nNode.js is designed to be fast, scalable, and efficient, making it well-suited for building real-time applications, APIs, server-side applications, and more.\n\nKey features of Node.js include:\n1. Asynchronous, Non-Blocking I/O: Node.js uses an event-driven, non-blocking I/O model, allowing it to handle multiple concurrent operations efficiently without blocking the execution of other code. This makes it ideal for handling high volumes of concurrent requests.\n2. Built-in Modules: Node.js provides a set of core modules that enable various functionalities, such as 'http' for creating web servers, 'fs' for file system operations, 'path' for handling file paths, and more.\n3. npm (Node Package Manager): npm is the default package manager for Node.js, and it is the largest ecosystem of open-source libraries and modules. Developers can easily install and manage third-party packages for their projects using npm.\n4. Cross-Platform: Node.js is cross-platform, which means it can run on various operating systems, including Windows, macOS, and Linux.\n5. Single-Threaded Event Loop: Node.js operates on a single-threaded event loop, but it can leverage the underlying operating system's multi-threaded capabilities to handle I/O operations efficiently.\n6. Expressive Syntax: Node.js has a simple and expressive syntax that makes it easy to write server-side code using JavaScript, making it accessible to front-end developers familiar with the language.\n\nExample of creating a basic HTTP server with Node.js:\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end('Hello, Node.js!');\n});\n\nserver.listen(3000, () => {\n    console.log('Server is running at http://localhost:3000/');\n});\n",
      "example": ""
    },
    {
      "name": "npm",
      "define": "npm (Node Package Manager) is the default package manager for Node.js, and it is the largest package registry for JavaScript libraries and modules. It allows developers to easily discover, install, and manage third-party packages for their Node.js projects.\n\nnpm operates through the command-line interface (CLI) and provides a vast ecosystem of open-source packages that can be easily integrated into projects. It also enables developers to publish and share their own packages with the community.\n\nKey features of npm include:\n1. Installation: npm provides a straightforward way to install packages from the npm registry into your project. It reads the dependencies specified in the 'package.json' file and installs them in the 'node_modules' directory.\n\nExample of installing a package using npm:\nnpm install packageName\n\n2. package.json: The 'package.json' file is a crucial part of any Node.js project. It contains metadata about the project, including its name, version, dependencies, scripts, and more. Developers can use the 'npm init' command to create a new 'package.json' file or modify an existing one.\n\n3. Semantic Versioning: npm follows semantic versioning, where package versions consist of three numbers: 'MAJOR.MINOR.PATCH'. This allows developers to define version ranges for dependencies, ensuring compatibility and stability.\n\nExample of specifying a package version in 'package.json':\n\"dependencies\": {\n    \"packageName\": \"^1.2.0\"\n}\n\n4. Scripts: The 'package.json' file also contains a 'scripts' section, allowing developers to define custom commands to be executed using 'npm run <scriptName>'.\n\nExample of defining a script in 'package.json':\n\"scripts\": {\n    \"start\": \"node app.js\"\n}\n\n5. Publishing: Developers can publish their own packages to the npm registry, making them available for other developers to use. The 'npm publish' command is used to publish packages.\n\nExample of publishing a package to npm:\nnpm publish\n\n6. Version Management: npm provides commands to update packages to their latest versions, check for outdated dependencies, and manage version conflicts.\n\nExample of checking for outdated packages:\nnpm outdated\n\nnpm plays a crucial role in the Node.js ecosystem and facilitates the sharing and collaboration of code among developers worldwide.\n",
      "example": ""
    },
    {
      "name": "null",
      "define": "In JavaScript, 'null' is a special value that represents the absence of any value or an empty reference. It is a primitive data type and typically used to indicate that a variable or object property has no value or has not been assigned a value yet.\n\nExample of assigning a variable to null:\nlet value = null;\n\nThe typeof 'null' is 'object', which is a historical mistake and not a precise representation of its nature. To check if a variable is 'null', you can use the '===' or '!===' strict equality operators.\n\nExample of checking for null:\nlet value = null;\nif (value === null) {\n    console.log('The value is null.');\n}\n\nIt's essential to distinguish between 'null' and 'undefined'. 'null' is a value that can be explicitly assigned, while 'undefined' typically represents an uninitialized variable or an object property that does not exist.\n\nExample of 'undefined':\nlet name;\nconsole.log(name); // Output: undefined\n\nWhen working with APIs or data sources, 'null' is commonly used to represent the absence of data or a valid response.\n",
      "example": ""
    },
    {
      "name": "object",
      "define": "In JavaScript, an object is a composite data type that allows you to store collections of key-value pairs. Objects are fundamental to JavaScript and play a central role in the language.\n\nObjects can be created using either the object literal notation (curly braces) or the 'Object' constructor.\n\nExample of creating an object using object literal notation:\nconst person = {\n    name: 'John Doe',\n    age: 30,\n    isEmployed: true\n};\n\nExample of creating an object using the 'Object' constructor:\nconst person = new Object();\nperson.name = 'John Doe';\nperson.age = 30;\nperson.isEmployed = true;\n\nObjects in JavaScript are dynamic, which means you can add, modify, or delete properties at any time.\n\nAccessing Object Properties:\nYou can access the properties of an object using dot notation or square brackets notation.\n\nExample of accessing object properties:\nconst person = {\n    name: 'John Doe',\n    age: 30,\n    isEmployed: true\n};\n\nconsole.log(person.name); // Output: 'John Doe'\nconsole.log(person['age']); // Output: 30\n\nIterating Over Object Properties:\nTo loop through the properties of an object, you can use a 'for...in' loop or methods like 'Object.keys()', 'Object.values()', or 'Object.entries()' introduced in ES6.\n\nExample of iterating over object properties with 'for...in' loop:\nconst person = {\n    name: 'John Doe',\n    age: 30,\n    isEmployed: true\n};\n\nfor (const key in person) {\n    console.log(key + ': ' + person[key]);\n}\n\nObjects are widely used in JavaScript for representing data structures, configurations, and complex entities in applications.\n",
      "example": ""
    },
    {
      "name": "promise",
      "define": "A promise is an object in JavaScript used for handling asynchronous operations. It represents a value that may not be available yet but will be resolved (fulfilled) or rejected in the future, typically after an asynchronous operation completes.\n\nPromises provide a cleaner and more readable way to deal with asynchronous code compared to traditional callbacks, known as \"callback hell.\"\n\nCreating a Promise:\nA Promise is created using the 'Promise' constructor, which takes a callback function with two arguments: 'resolve' and 'reject'. Inside the callback, you perform the asynchronous operation and call 'resolve()' when the operation is successful or 'reject()' when it encounters an error.\n\nExample of creating a simple Promise:\nconst promise = new Promise((resolve, reject) => {\n    // Simulating an asynchronous operation\n    setTimeout(() => {\n        const data = 'Async operation completed successfully!';\n        resolve(data); // The promise is fulfilled with the data\n    }, 2000);\n});\n\nHandling Promise Results:\nTo handle the result of a Promise, you use the 'then()' method. It takes two callback functions as arguments: the first for the fulfilled (successful) case and the second for the rejected (error) case.\n\nExample of handling the result of a Promise:\npromise.then(\n    (data) => {\n        console.log(data); // Output: 'Async operation completed successfully!'\n    },\n    (error) => {\n        console.error(error);\n    }\n);\n\nChaining Promises:\nPromises can be chained together using the 'then()' method. This is useful for sequential asynchronous operations or transforming the data between steps.\n\nExample of chaining Promises:\nfunction fetchData() {\n    return new Promise((resolve, reject) => {\n        // Simulating an asynchronous operation\n        setTimeout(() => {\n            const data = 'Async operation completed successfully!';\n            resolve(data);\n        }, 2000);\n    });\n}\n\nfetchData()\n    .then((data) => {\n        console.log(data); // Output: 'Async operation completed successfully!'\n        return data.toUpperCase();\n    })\n    .then((upperCaseData) => {\n        console.log(upperCaseData); // Output: 'ASYNC OPERATION COMPLETED SUCCESSFULLY!'\n    })\n    .catch((error) => {\n        console.error(error);\n    });\n\nThe 'catch()' method is used to handle errors in the Promise chain. It will catch any rejected promises in the chain.\n\nAsync/Await:\nES8 introduced async/await, which provides a more synchronous-looking syntax for handling promises. The 'async' keyword is used to define an asynchronous function, and 'await' is used to wait for the promise to resolve or reject.\n\nExample of using async/await:\nasync function fetchData() {\n    return new Promise((resolve, reject) => {\n        // Simulating an asynchronous operation\n        setTimeout(() => {\n            const data = 'Async operation completed successfully!';\n            resolve(data);\n        }, 2000);\n    });\n}\n\nasync function processAsyncData() {\n    try {\n        const data = await fetchData();\n        console.log(data); // Output: 'Async operation completed successfully!'\n    } catch (error) {\n        console.error(error);\n    }\n}\n\nprocessAsyncData();\n",
      "example": ""
    },
    {
      "name": "prototype",
      "define": "In JavaScript, every object is associated with a prototype object, which acts as a blueprint for that object. The prototype contains properties and methods that are inherited by all instances of that object type.\n\nPrototypes form the basis of JavaScript's prototypal inheritance model. When you access a property or method on an object, and it is not found on the object itself, JavaScript will look for it in the object's prototype chain.\n\nCreating Objects with Prototypes:\nIn JavaScript, you can create objects and link them to prototypes using either constructor functions or the modern class syntax introduced in ES6.\n\nExample using constructor function:\nfunction Person(name) {\n    this.name = name;\n}\nPerson.prototype.sayHello = function() {\n    console.log('Hello, my name is ' + this.name);\n};\n\nconst john = new Person('John');\njohn.sayHello(); // Output: 'Hello, my name is John'\n\nIn the example above, 'Person.prototype' becomes the prototype of all instances created with the 'Person' constructor. Any object created with 'new Person()' will have access to the 'sayHello' method through the prototype chain.\n\nClass syntax (ES6 and beyond):\nclass Person {\n    constructor(name) {\n        this.name = name;\n    }\n\n    sayHello() {\n        console.log('Hello, my name is ' + this.name);\n    }\n}\n\nconst john = new Person('John');\njohn.sayHello(); // Output: 'Hello, my name is John'\n\nObject.prototype:\nThe 'Object.prototype' is the ultimate prototype in JavaScript. It is the topmost object in the prototype chain and includes methods and properties inherited by all objects.\n\nExample of a common method from 'Object.prototype':\nconst person = {\n    name: 'John',\n    age: 30\n};\n\nconsole.log(Object.keys(person)); // Output: ['name', 'age']\n\nIn the example above, 'Object.keys()' is used to retrieve an array of the object's own enumerable property names. The 'Object.keys()' method is available to all objects in JavaScript since all objects inherit from 'Object.prototype'.\n\nIt's important to be cautious when modifying the 'Object.prototype' or adding properties directly to it, as this can lead to unexpected behavior and compatibility issues with other code.\n",
      "example": ""
    },
    {
      "name": "react",
      "define": "React is a popular JavaScript library for building user interfaces. It was developed and is maintained by Facebook. React allows developers to create reusable UI components and efficiently manage the state of an application, making it an essential tool for building interactive and dynamic web applications.\n\nKey features of React include:\n1. Component-Based Architecture: React follows a component-based architecture, where UIs are divided into smaller, reusable components. This encourages code reusability and maintainability.\n2. Virtual DOM: React uses a virtual representation of the actual DOM, called the Virtual DOM, to optimize rendering. When the state of a component changes, React efficiently updates only the necessary parts of the actual DOM, reducing the number of expensive DOM operations.\n3. JSX (JavaScript XML): React uses JSX, which is a syntax extension for JavaScript. JSX allows developers to write HTML-like code directly in JavaScript, making it easier to describe the structure of the UI.\n4. Unidirectional Data Flow: React follows a unidirectional data flow, meaning data flows only in one direction, from parent components to child components. This makes the application more predictable and easier to debug.\n5. React Hooks: Introduced in React 16.8, hooks are functions that allow developers to use state and other React features in functional components, eliminating the need for class components in many cases.\n6. React Router: React Router is a library that provides routing capabilities to React applications, enabling developers to build single-page applications with multiple views.\n7. Context API: React's Context API allows developers to pass data through the component tree without the need to pass props down explicitly at each level.\n8. React Native: React can be used to build native mobile applications through React Native, a framework that allows developers to write mobile apps using JavaScript and React components. React Native provides a bridge between JavaScript and the native components of the target platform.\n\nExample of a simple React component using JSX:\nimport React from 'react';\n\nconst Greeting = () => {\n    return <h1>Hello, React!</h1>;\n};\n\n9. Reusable Components: React promotes reusability, and developers can create their own custom components and use them throughout the application.\n\nExample of a reusable custom component:\nimport React from 'react';\n\nconst Button = ({ onClick, children }) => {\n    return <button onClick={onClick}>{children}</button>;\n};\n\n10. Developer Tools: React has excellent developer tools that help with debugging, inspecting components, and monitoring performance.\n\nReact has a thriving ecosystem, with a vast number of third-party libraries and extensions available through npm. Its flexibility, performance optimizations, and ease of development have made it a popular choice for frontend development.\n",
      "example": ""
    },
    {
      "name": "recursion",
      "define": "Recursion is a programming technique where a function calls itself to solve a problem. Instead of using iterative loops, recursion allows developers to break down complex problems into smaller, more manageable subproblems.\n\nIn recursion, there are two main components:\n1. Base Case: The base case is the condition that terminates the recursion. It provides a stopping point to prevent infinite recursion and defines the simplest version of the problem that can be directly solved without further recursion.\n2. Recursive Case: The recursive case is where the function calls itself with a modified version of the problem to move towards the base case. Each recursive call solves a smaller part of the problem until the base case is reached.\n\nExample of a simple recursive function to calculate factorial:\nfunction factorial(n) {\n    if (n === 0 || n === 1) {\n        return 1; // Base case\n    } else {\n        return n * factorial(n - 1); // Recursive case\n    }\n}\n\nconsole.log(factorial(5)); // Output: 120 (5! = 5 * 4 * 3 * 2 * 1 = 120)\n\nRecursion can be a powerful technique for solving problems that have a repetitive or self-similar structure. However, it's essential to ensure that there is a proper base case and that the recursion does not result in infinite loops.\n\nTail Recursion:\nTail recursion is a specific form of recursion where the recursive call is the last operation performed in the function before returning a value. Some programming languages and compilers can optimize tail-recursive functions to avoid stack overflow errors.\n\nExample of a tail-recursive function for calculating factorial:\nfunction factorial(n, acc = 1) {\n    if (n === 0) {\n        return acc;\n    } else {\n        return factorial(n - 1, acc * n);\n    }\n}\n\nconsole.log(factorial(5)); // Output: 120 (5! = 5 * 4 * 3 * 2 * 1 = 120)\n\nWhile recursion can be an elegant solution for certain problems, it may not always be the most efficient approach. In some cases, iterative solutions or other algorithms may offer better performance and readability.\n",
      "example": ""
    },
    {
      "name": "redux",
      "define": "Redux is a state management library for JavaScript applications, particularly those built with frameworks like React. It provides a predictable state container that helps manage the state of an application in a consistent and organized way.\n\nKey concepts of Redux include:\n1. Store: The store is a single source of truth for the entire application state. It holds the complete state tree and allows access to the state using a 'getState()' method. The state in the Redux store is read-only, and the only way to change it is by dispatching actions.\n\n2. Actions: Actions are plain JavaScript objects that represent the intention to change the state. They are dispatched to the Redux store using the 'dispatch()' method. Actions must have a 'type' property that describes the type of action being performed.\n\nExample of a Redux action:\nconst incrementCounter = {\n    type: 'INCREMENT',\n};\n\n3. Reducers: Reducers are pure functions that take the current state and an action as arguments and return a new state based on the action type. Reducers define how the application's state changes in response to actions. They should not modify the original state but create a new copy with the desired changes.\n\nExample of a simple Redux reducer:\nconst counterReducer = (state = 0, action) => {\n    switch (action.type) {\n        case 'INCREMENT':\n            return state + 1;\n        default:\n            return state;\n    }\n};\n\n4. Dispatching Actions: To modify the state in the Redux store, you dispatch actions using the 'dispatch()' method. The store then calls the appropriate reducer, updates the state, and notifies all subscribed components of the state change.\n\nExample of dispatching an action in a React component:\nimport { useDispatch } from 'react-redux';\nimport { incrementCounter } from './actions';\n\nconst CounterComponent = () => {\n    const dispatch = useDispatch();\n\n    const handleIncrement = () => {\n        dispatch(incrementCounter());\n    };\n\n    return (\n        <div>\n            <button onClick={handleIncrement}>Increment</button>\n        </div>\n    );\n};\n\n5. Middleware: Redux allows the use of middleware, which are functions that intercept dispatched actions before they reach the reducers. Middleware can be used for various purposes, such as logging actions, making asynchronous calls, or modifying actions before they reach the reducers.\n\nExample of using Redux middleware (thunk) for making an asynchronous API call:\nimport { useDispatch } from 'react-redux';\nimport { fetchData } from './actions';\n\nconst DataComponent = () => {\n    const dispatch = useDispatch();\n\n    useEffect(() => {\n        dispatch(fetchData()); // Dispatch an action to fetch data asynchronously\n    }, []);\n\n    // ...\n};\n\n6. React-Redux: React-Redux is a library that provides integration between React and Redux. It allows React components to interact with the Redux store, dispatch actions, and subscribe to changes in the store.\n\nExample of connecting a React component to the Redux store:\nimport { useSelector, useDispatch } from 'react-redux';\nimport { incrementCounter } from './actions';\n\nconst CounterComponent = () => {\n    const count = useSelector(state => state.counter);\n    const dispatch = useDispatch();\n\n    const handleIncrement = () => {\n        dispatch(incrementCounter());\n    };\n\n    return (\n        <div>\n            <p>Count: {count}</p>\n            <button onClick={handleIncrement}>Increment</button>\n        </div>\n    );\n};\n\nRedux provides a well-defined pattern for managing application state, making it easier to reason about complex state changes and ensuring that the state remains predictable and consistent across the entire application.\n",
      "example": ""
    },
    {
      "name": "regexp",
      "define": "A regular expression, often abbreviated as regexp or regex, is a powerful pattern-matching tool used in JavaScript and many other programming languages. It allows developers to search, match, and manipulate text based on patterns.\n\nIn JavaScript, regular expressions are represented by objects of the 'RegExp' class or by using a regex literal notation, which is enclosed in forward slashes ('/').\n\nExample of a regular expression to match all occurrences of the word 'hello' in a text:\nconst text = 'Hello, hello, and hello again!';\nconst regex = /hello/g; // 'g' flag for global search\n\nconst matches = text.match(regex);\nconsole.log(matches); // Output: ['hello', 'hello', 'hello']\n\nCommon Flags for Regular Expressions:\n1. 'g' (Global): When this flag is used, the regular expression searches for all occurrences of the pattern, not just the first one.\n\n2. 'i' (Case-Insensitive): With this flag, the regular expression ignores the case while matching, so 'A' will match 'a', and vice versa.\n\n3. 'm' (Multiline): When enabled, the '^' and '$' anchors match the start and end of each line instead of the whole string.\n\nExample of using flags:\nconst text = 'Hello, hello, and hello again!';\nconst regex = /hello/gi; // 'g' and 'i' flags\n\nconst matches = text.match(regex);\nconsole.log(matches); // Output: ['Hello', 'hello', 'hello']\n\nCommon Methods for Regular Expressions:\n1. 'test()': The 'test()' method checks if the pattern matches any part of the given string and returns a boolean.\n\nExample of using 'test()':\nconst text = 'Hello, World!';\nconst regex = /hello/i;\n\nconst isMatch = regex.test(text);\nconsole.log(isMatch); // Output: true\n\n2. 'match()': The 'match()' method returns an array containing all matches of the pattern in the given string. If the 'g' flag is used, it returns all matches; otherwise, it returns only the first match and additional information.\n\n3. 'exec()': The 'exec()' method returns an array containing details about the first match or null if no match is found. If the 'g' flag is used, it returns successive matches on each call.\n\nExample of using 'exec()':\nconst text = 'Hello, World!';\nconst regex = /hello/i;\n\nlet result;\nwhile ((result = regex.exec(text)) !== null) {\n    console.log('Found match:', result[0]);\n}\n\nRegular expressions are extremely versatile and can be used for tasks like validation, text search and replace, extracting data from strings, and more. However, they can also be complex and challenging to read and write, especially for beginners.\n",
      "example": ""
    },
    {
      "name": "scope",
      "define": "Scope in JavaScript refers to the context in which variables and functions are accessible. It determines the visibility and lifetime of variables and defines where a particular value can be accessed or modified within a program.\n\nIn JavaScript, there are two main types of scope:\n1. Global Scope: Variables declared outside any function or block have global scope and can be accessed from anywhere within the script. Global variables are attached to the global object ('window' in browsers, 'global' in Node.js).\n\nExample of a global variable:\nconst globalVar = 'I am global!';\n\nfunction exampleFunction() {\n    console.log(globalVar); // Output: 'I am global!'\n}\n\n2. Local Scope: Variables declared within a function or block have local scope and are accessible only within that specific function or block. Local variables are not visible outside the function or block where they are defined.\n\nExample of a local variable:\nfunction exampleFunction() {\n    const localVar = 'I am local!';\n    console.log(localVar); // Output: 'I am local!'\n}\n\nconsole.log(localVar); // Error: 'localVar' is not defined\n\nShadowing:\nWhen a variable in a local scope has the same name as a variable in a higher-level scope, it is said to \"shadow\" the outer variable. The inner variable takes precedence over the outer variable within its scope.\n\nExample of variable shadowing:\nconst message = 'Hello, global!';\n\nfunction exampleFunction() {\n    const message = 'Hi, local!';\n    console.log(message); // Output: 'Hi, local!'\n}\n\nexampleFunction();\nconsole.log(message); // Output: 'Hello, global!'\n\nBlock Scope:\nPrior to ES6 (ECMAScript 2015), JavaScript had function scope, which meant variables were only scoped to the function in which they were declared. However, ES6 introduced block scope with the 'let' and 'const' keywords.\n\nExample of block scope using 'let':\nfunction exampleFunction() {\n    if (true) {\n        let blockVar = 'I am block-scoped!';\n        console.log(blockVar); // Output: 'I am block-scoped!'\n    }\n    console.log(blockVar); // Error: 'blockVar' is not defined\n}\n\nLexical Scope (Closures):\nLexical scope, also known as closures, is a concept where a function can access variables from its containing (outer) scope, even after the outer function has finished executing.\n\nExample of a closure:\nfunction outerFunction() {\n    const outerVar = 'I am outer!';\n\n    function innerFunction() {\n        console.log(outerVar); // Output: 'I am outer!'\n    }\n\n    return innerFunction;\n}\n\nconst closureFunc = outerFunction();\nclosureFunc();\n\nIn the example above, 'innerFunction' forms a closure over 'outerVar', allowing it to access the variable even after 'outerFunction' has finished executing.\n\nUnderstanding scope is essential for managing variable names, avoiding naming conflicts, and optimizing memory usage in JavaScript programs.\n",
      "example": ""
    },
    {
      "name": "set",
      "define": "In JavaScript, 'Set' is a built-in data structure that represents an ordered collection of unique values. Unlike arrays, 'Set' does not allow duplicate elements, which means every value in a 'Set' must be unique.\n\nCreating a Set:\nYou can create a new 'Set' by passing an iterable (such as an array) to the 'Set' constructor.\n\nExample of creating a Set:\nconst mySet = new Set([1, 2, 3, 3, 4, 5]);\n\nconsole.log(mySet); // Output: Set { 1, 2, 3, 4, 5 }\n\nSet Methods:\nSets have various methods to manipulate and retrieve elements.\n\n1. 'add(value)': Adds a new element to the Set. If the value already exists, it will not be added again.\n\nExample of using 'add()':\nconst mySet = new Set();\nmySet.add(1);\nmySet.add(2);\nmySet.add(3);\nmySet.add(3); // Duplicate value, will be ignored\n\nconsole.log(mySet); // Output: Set { 1, 2, 3 }\n\n2. 'delete(value)': Removes the specified value from the Set.\n\nExample of using 'delete()':\nconst mySet = new Set([1, 2, 3]);\nmySet.delete(2);\n\nconsole.log(mySet); // Output: Set { 1, 3 }\n\n3. 'has(value)': Checks if the specified value is present in the Set and returns a boolean.\n\nExample of using 'has()':\nconst mySet = new Set([1, 2, 3]);\nconsole.log(mySet.has(2)); // Output: true\nconsole.log(mySet.has(4)); // Output: false\n\n4. 'size': Returns the number of elements in the Set.\n\nExample of using 'size':\nconst mySet = new Set([1, 2, 3]);\nconsole.log(mySet.size); // Output: 3\n\n5. 'clear()': Removes all elements from the Set, making it empty.\n\nExample of using 'clear()':\nconst mySet = new Set([1, 2, 3]);\nmySet.clear();\n\nconsole.log(mySet); // Output: Set {}\n\nIterating through a Set:\nSets can be iterated using loops or the 'forEach()' method.\n\nExample of iterating through a Set using a loop:\nconst mySet = new Set([1, 2, 3]);\n\nfor (const value of mySet) {\n    console.log(value);\n}\n// Output:\n// 1\n// 2\n// 3\n\nExample of iterating through a Set using 'forEach()':\nconst mySet = new Set([1, 2, 3]);\n\nmySet.forEach((value) => {\n    console.log(value);\n});\n// Output:\n// 1\n// 2\n// 3\n\nConverting Set to Array:\nTo convert a Set to an array, you can use the 'Array.from()' method or the spread operator.\n\nExample of converting a Set to an array using 'Array.from()':\nconst mySet = new Set([1, 2, 3]);\nconst myArray = Array.from(mySet);\n\nconsole.log(myArray); // Output: [1, 2, 3]\n\nExample of converting a Set to an array using the spread operator:\nconst mySet = new Set([1, 2, 3]);\nconst myArray = [...mySet];\n\nconsole.log(myArray); // Output: [1, 2, 3]\n\nSets are useful when you need to ensure uniqueness and don't require the elements to be indexed, as in the case of arrays.\n",
      "example": ""
    },
    {
      "name": "setTimeout",
      "trigger": "set timeout",
      "define": "'setTimeout' is a built-in function in JavaScript used to schedule the execution of a function (or an expression) after a specified delay in milliseconds. It allows you to introduce time-based operations in JavaScript, such as delaying the execution of a piece of code or implementing animations.\n\nSyntax of 'setTimeout':\nThe basic syntax of 'setTimeout' is as follows:\nsetTimeout(callbackFunction, delayInMilliseconds, arg1, arg2, ...);\n\nParameters:\n- 'callbackFunction': The function to be executed after the specified delay.\n- 'delayInMilliseconds': The time delay in milliseconds before executing the function.\n- 'arg1', 'arg2', ...: Optional arguments that can be passed to the callbackFunction.\n\nExample of using 'setTimeout':\nfunction delayedGreeting(name) {\n    console.log('Hello, ' + name + '!');\n}\n\nsetTimeout(delayedGreeting, 2000, 'John');\n// After 2 seconds, the function 'delayedGreeting' will be called with the argument 'John'\n// Output after 2 seconds: 'Hello, John!'\n\nClearing a Timeout:\nYou can cancel a scheduled timeout using the 'clearTimeout()' method. This prevents the callback function from being executed if the timeout has not already occurred.\n\nSyntax of 'clearTimeout':\nconst timeoutID = setTimeout(callbackFunction, delayInMilliseconds);\nclearTimeout(timeoutID);\n\nExample of clearing a timeout:\nfunction delayedGreeting(name) {\n    console.log('Hello, ' + name + '!');\n}\n\nconst timeoutID = setTimeout(delayedGreeting, 2000, 'John');\nclearTimeout(timeoutID); // The timeout is cleared, and 'delayedGreeting' will not be executed\n\nRepeating a Function with 'setInterval':\nThe 'setInterval' function is similar to 'setTimeout', but instead of executing the callback function once after the delay, it repeatedly executes the callback at a specified interval until cleared.\n\nSyntax of 'setInterval':\nconst intervalID = setInterval(callbackFunction, intervalInMilliseconds, arg1, arg2, ...);\n\nParameters:\n- 'callbackFunction': The function to be repeatedly executed.\n- 'intervalInMilliseconds': The time interval in milliseconds between each execution.\n- 'arg1', 'arg2', ...: Optional arguments that can be passed to the callbackFunction.\n\nExample of using 'setInterval':\nfunction printTime() {\n    console.log(new Date().toLocaleTimeString());\n}\n\nconst intervalID = setInterval(printTime, 1000);\n// Output every second: the current time in the local time zone\n\nTo stop the repeated execution, you can use 'clearInterval(intervalID)'.\n\nUsing 'setTimeout' and 'setInterval' is essential for handling time-dependent operations in JavaScript, such as animations, delayed actions, or periodic updates.\n",
      "example": ""
    },
    {
      "name": "strict mode",
      "trigger": "strict mode",
      "define": "Strict mode is a feature introduced in ECMAScript 5 (ES5) to make JavaScript code more robust by enforcing stricter rules and eliminating certain unsafe and problematic language features. When strict mode is enabled, the JavaScript runtime will report errors for common coding mistakes, which helps developers write more reliable and maintainable code.\n\nEnabling Strict Mode:\nStrict mode is enabled by adding the following string literal at the beginning of a script or function:\n'use strict';\n\nGlobal Strict Mode:\nIn a global context (outside any function), enabling strict mode affects the entire script.\n\nExample of enabling strict mode in a script:\n'use strict';\n\n// Now, the entire script is in strict mode\n// Any mistakes or unsafe practices will throw errors\n\nFunction Strict Mode:\nIn a function scope, enabling strict mode affects only that specific function and its inner functions.\n\nExample of enabling strict mode in a function:\nfunction myFunction() {\n    'use strict';\n\n    // Only this function and its inner functions are in strict mode\n}\n\nStrict Mode Rules and Benefits:\n1. Prevents Undeclared Variables: In non-strict mode, assigning a value to an undeclared variable creates a global variable. In strict mode, this behavior is disallowed, and assigning to an undeclared variable will result in a reference error.\n\n2. Eliminates Octal Literal Syntax: Octal number syntax, like '012', is not allowed in strict mode, as it can be confusing and error-prone.\n\n3. Disallows Duplicate Function Parameters: Strict mode prevents the use of duplicate parameter names in function declarations or expressions.\n\n4. Prohibits 'with' Statement: The 'with' statement, which can lead to unpredictable behavior and performance issues, is not allowed in strict mode.\n\n5. Prevents Overwriting of Properties in Objects: In non-strict mode, it is possible to accidentally overwrite non-writable properties of an object silently. In strict mode, such assignments will throw a type error.\n\n6. Requires 'eval' and 'arguments' to Be Treated as Keywords: In strict mode, 'eval' and 'arguments' are reserved keywords, meaning they cannot be used as variable names.\n\n7. Eliminates 'delete' on Non-Configurable Properties: In strict mode, 'delete' cannot be used to remove properties that are marked as non-configurable.\n\nExample of a strict mode violation:\n'use strict';\nx = 10; // Error: 'x' is not defined\n\nAdvantages of Strict Mode:\n- Helps catch errors and potential bugs early in development.\n- Encourages better coding practices and avoids common pitfalls.\n- Makes the code easier to optimize by the JavaScript engine, leading to potential performance improvements.\n\nNote: It's recommended to use strict mode in all JavaScript code to ensure better code quality and maintainability.\n",
      "example": ""
    },
    {
      "name": "string",
      "define": "In JavaScript, a 'string' is a data type that represents a sequence of characters. Strings are used to store and manipulate text-based data, such as names, sentences, or any other textual information.\n\nCreating Strings:\nStrings can be created in JavaScript using single quotes (''), double quotes (\"\"), or backticks (``). Backticks, introduced in ECMAScript 6 (ES6), are used for template literals, which offer advanced string interpolation features.\n\nExamples of creating strings:\nconst singleQuotesString = 'Hello, I am a string.';\nconst doubleQuotesString = \"I am also a string.\";\nconst templateLiteralString = `I am a template literal string.`;\n\nSpecial Characters in Strings:\nStrings can contain special escape sequences to represent characters that cannot be typed directly, such as newlines, tabs, or quotation marks.\n\nExamples of special escape sequences:\nconst newLineString = \"First line\nSecond line\";\nconst tabString = \"Name:\tJohn\";\nconst quoteString = \"He said, \"Hello!\"\";\n\nString Length:\nTo get the length of a string (the number of characters), you can use the 'length' property of the string object.\n\nExample of getting the length of a string:\nconst myString = \"Hello, World!\";\nconsole.log(myString.length); // Output: 13\n\nString Concatenation:\nYou can concatenate (combine) strings using the '+' operator.\n\nExample of string concatenation:\nconst firstName = \"John\";\nconst lastName = \"Doe\";\nconst fullName = firstName + \" \" + lastName;\nconsole.log(fullName); // Output: \"John Doe\"\n\nString Methods:\nJavaScript provides several built-in methods to manipulate strings, such as converting case, extracting substrings, finding substrings, and replacing substrings.\n\nExamples of string methods:\nconst myString = \"Hello, World!\";\n\n// Converting case\nconsole.log(myString.toUpperCase()); // Output: \"HELLO, WORLD!\"\nconsole.log(myString.toLowerCase()); // Output: \"hello, world!\"\n\n// Extracting substrings\nconsole.log(myString.slice(0, 5)); // Output: \"Hello\"\nconsole.log(myString.substring(7, 12)); // Output: \"World\"\nconsole.log(myString.substr(7, 5)); // Output: \"World\"\n\n// Finding substrings\nconsole.log(myString.indexOf(\"World\")); // Output: 7 (index of the first occurrence)\nconsole.log(myString.lastIndexOf(\"o\")); // Output: 8 (index of the last occurrence)\n\n// Replacing substrings\nconsole.log(myString.replace(\"World\", \"Universe\")); // Output: \"Hello, Universe!\"\n\nStrings are fundamental to working with textual data in JavaScript, and understanding string manipulation methods is crucial for many types of applications, including web development and data processing.\n",
      "example": ""
    },
    {
      "name": "symbol",
      "define": "'Symbol' is a primitive data type introduced in ECMAScript 6 (ES6) to create unique and immutable values that can be used as object property keys. Symbols are used to prevent unintended property name collisions in objects and provide a level of privacy for object properties.\n\nCreating Symbols:\nSymbols are created using the 'Symbol()' function, which returns a unique symbol value.\n\nExample of creating a symbol:\nconst mySymbol = Symbol();\n\nEach symbol value is guaranteed to be unique, even if you create multiple symbols with the same description.\n\nExample of creating symbols with the same description:\nconst symbol1 = Symbol('mySymbol');\nconst symbol2 = Symbol('mySymbol');\n\nconsole.log(symbol1 === symbol2); // Output: false (each symbol is unique)\n\nUsing Symbols as Object Properties:\nSymbols can be used as property keys in objects, providing a way to define \"hidden\" or \"private\" properties that are not accessible using normal object property access.\n\nExample of using a symbol as an object property key:\nconst mySymbol = Symbol('mySymbol');\nconst myObject = {};\n\nmyObject[mySymbol] = 'Hello, Symbol!';\nconsole.log(myObject[mySymbol]); // Output: \"Hello, Symbol!\"\n\nEnumerating Object Properties with Symbols:\nSymbols are not enumerable, which means they are not included when using 'for...in' loops or 'Object.keys()' to iterate through an object's properties.\n\nExample of enumerating object properties excluding symbols:\nconst mySymbol = Symbol('mySymbol');\nconst myObject = {\n    [mySymbol]: 'Hello, Symbol!',\n    name: 'John',\n    age: 30\n};\n\nfor (const key in myObject) {\n    console.log(key); // Output: \"name\", \"age\" (symbols are not included)\n}\n\nRetrieving Symbol Descriptions:\nThe description of a symbol can be obtained using the 'description' property of the symbol object.\n\nExample of retrieving the description of a symbol:\nconst mySymbol = Symbol('mySymbol');\nconsole.log(mySymbol.description); // Output: \"mySymbol\"\n\nBuilt-in Symbols:\nES6 introduced several built-in symbols that have special meanings or behaviors. These symbols are used, for example, to define custom iterator methods, well-known method names, and more.\n\nExample of using a built-in symbol:\nconst myIterableObject = {\n    [Symbol.iterator]() {\n        let count = 1;\n        return {\n            next() {\n                return count <= 5 ? { value: count++, done: false } : { done: true };\n            }\n        };\n    }\n};\n\nfor (const item of myIterableObject) {\n    console.log(item); // Output: 1, 2, 3, 4, 5\n}\n\nSymbols are a powerful tool for creating unique and private object properties, and they play a significant role in enhancing the functionality and security of JavaScript code.\n",
      "example": ""
    },
    {
      "name": "this",
      "define": "'this' is a special keyword in JavaScript that refers to the object on which the current code (function or method) is being executed. It provides a way to access the context or scope within which the code is running. The value of 'this' depends on how a function is called and not where it is defined.\n\nThe Value of 'this':\nThe value of 'this' can vary based on the function's invocation context:\n1. Global Context: When 'this' is referenced in the global scope (outside any function or object), it refers to the global object (e.g., 'window' in browsers, 'global' in Node.js).\n\nExample of 'this' in the global context:\nconsole.log(this === window); // Output: true (in browsers)\n\n2. Function Context: When 'this' is referenced inside a regular function (not an arrow function) that is called directly, 'this' also refers to the global object.\n\nExample of 'this' in a regular function:\nfunction myFunction() {\n    console.log(this === window); // Output: true (in browsers)\n}\n\nmyFunction();\n\n3. Method Context: When 'this' is referenced inside a method (function within an object), 'this' refers to the object that owns the method.\n\nExample of 'this' in a method:\nconst myObject = {\n    name: 'John',\n    sayHello() {\n        console.log('Hello, ' + this.name + '!');\n    }\n};\n\nmyObject.sayHello(); // Output: \"Hello, John!\"\n\n4. Constructor Context: When 'this' is referenced inside a constructor function (used with 'new' keyword to create objects), 'this' refers to the newly created object instance.\n\nExample of 'this' in a constructor function:\nfunction Person(name) {\n    this.name = name;\n}\n\nconst john = new Person('John');\nconsole.log(john.name); // Output: \"John\"\n\nBinding 'this' Manually:\nThe value of 'this' can be manually bound to a specific object using methods like 'bind()', 'call()', or 'apply()'.\n\nExample of manually binding 'this':\nconst person = {\n    name: 'John',\n    greet() {\n        console.log('Hello, ' + this.name + '!');\n    }\n};\n\nconst greetFunction = person.greet.bind(person);\ngreetFunction(); // Output: \"Hello, John!\"\n\nUnderstanding 'this' is crucial for correctly accessing object properties and methods in various contexts in JavaScript.\n",
      "example": ""
    },
    {
      "name": "three.js",
      "trigger": "three js",
      "define": "Three.js is a popular and powerful JavaScript library used for 3D computer graphics and web-based 3D animations. It provides a simple and straightforward API for creating, rendering, and animating 3D scenes in the browser using WebGL, a technology that enables hardware-accelerated rendering of 2D and 3D graphics.\n\nKey Features of Three.js:\n1. Scene and Object Creation: Three.js allows you to create a 3D scene, which acts as a container for all the 3D objects in the scene. You can create various types of 3D objects, including meshes, lights, cameras, and more.\n\nExample of creating a 3D scene and a cube:\nconst scene = new THREE.Scene();\n\nconst geometry = new THREE.BoxGeometry();\nconst material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\nconst cube = new THREE.Mesh(geometry, material);\n\nscene.add(cube);\n",
      "example": "3D graphics in the browser using Three.js have become increasingly popular for creating interactive and visually appealing experiences. For more complex applications like games and simulations, Three.js offers a wide range of capabilities and tools for developers."
    },
    {
      "name": "typescript",
      "trigger": "type script",
      "define": "TypeScript is a superset of JavaScript developed by Microsoft. It adds optional static typing and other advanced features to JavaScript, making it a more robust and scalable language for large-scale applications. TypeScript code is transpiled into standard JavaScript, ensuring compatibility with all modern browsers and environments.\n\nKey Features of TypeScript:\n1. Static Typing: TypeScript allows developers to specify types for variables, function parameters, and return values. This helps catch type-related errors during development and provides better code documentation.\n\nExample of using static typing in TypeScript:\nfunction add(a: number, b: number): number {\n    return a + b;\n}\n\nconst result = add(5, 10); // 'result' will be inferred as type 'number'\n\n2. Interfaces: TypeScript introduces interfaces, which define the structure of objects. They enable better code organization and help prevent accidental property omissions or mismatches.\n\nExample of using an interface in TypeScript:\ninterface Person {\n    name: string;\n    age: number;\n}\n\nfunction greet(person: Person): string {\n    return 'Hello, ' + person.name;\n}\n\nconst john: Person = { name: 'John', age: 30 };\nconsole.log(greet(john)); // Output: \"Hello, John\"\n\n3. Enumerations: TypeScript supports enumerations, which allow developers to define a set of named constants. This provides a more expressive and type-safe way to work with groups of related values.\n\nExample of using an enumeration in TypeScript:\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\n\nconst selectedColor = Color.Green;\nconsole.log(selectedColor); // Output: 1\n\n4. Classes and Inheritance: TypeScript brings class-based object-oriented programming to JavaScript. Developers can define classes with constructors, methods, and properties, making code organization and reuse easier.\n\nExample of using classes and inheritance in TypeScript:\nclass Animal {\n    constructor(public name: string) {}\n    makeSound() {\n        console.log('Animal makes a sound');\n    }\n}\n\nclass Dog extends Animal {\n    makeSound() {\n        console.log('Dog barks');\n    }\n}\n\nconst dog = new Dog('Buddy');\ndog.makeSound(); // Output: \"Dog barks\"\n\nTypeScript's features improve code maintainability and provide a smoother development experience, especially in large projects with teams of developers.",
      "example": "\n            // Example of using TypeScript in a simple function\n            function multiply(a: number, b: number): number {\n                return a * b;\n            }\n\n            const result = multiply(5, 3);\n            console.log(result); // Output: 15\n        "
    },
    {
      "name": "undefined",
      "define": "'undefined' is a primitive value in JavaScript that represents an uninitialized, non-existent, or missing value. It is one of the six primitive data types (undefined, null, boolean, number, string, symbol) and is automatically assigned to variables that are declared but not initialized or do not have a value.\n\nExample of 'undefined':\nlet x;\nconsole.log(x); // Output: undefined\n\nIn the above example, the variable 'x' is declared but not assigned a value, so it is automatically initialized with 'undefined'.\n\nUse Cases of 'undefined':\n1. Uninitialized Variables: When a variable is declared but not assigned a value, it is set to 'undefined' by default.\n\nExample of an uninitialized variable:\nlet name;\nconsole.log(name); // Output: undefined\n\n2. Missing Object Properties: Accessing an object property that does not exist returns 'undefined'.\n\nExample of accessing a non-existent property:\nconst person = { name: 'John', age: 30 };\nconsole.log(person.address); // Output: undefined\n\n3. Function Return: If a function does not explicitly return a value, it returns 'undefined' by default.\n\nExample of a function without a return statement:\nfunction greet() {\n    console.log('Hello!');\n}\n\nconst result = greet();\nconsole.log(result); // Output: undefined\n\n4. Function Arguments: If a function is called with fewer arguments than declared in the function definition, the missing arguments are set to 'undefined'.\n\nExample of calling a function with fewer arguments:\nfunction add(a, b) {\n    return a + b;\n}\n\nconst result = add(5);\nconsole.log(result); // Output: NaN (Not a Number), as 'b' is undefined\n\nHandling 'undefined':\nDevelopers often use conditional statements or the 'typeof' operator to check if a variable is 'undefined' before using it, especially when working with optional values or function arguments.\n\nExample of handling 'undefined':\nfunction greet(name) {\n    if (typeof name === 'undefined') {\n        console.log('Hello, stranger!');\n    } else {\n        console.log('Hello, ' + name + '!');\n    }\n}\n\ngreet(); // Output: \"Hello, stranger!\"\ngreet('John'); // Output: \"Hello, John!\"\n\nBy understanding the behavior of 'undefined', developers can write more robust code and handle cases where values might be missing or not yet defined.",
      "example": "\n            // Example of checking for undefined before using a variable\n            let age;\n            if (typeof age === 'undefined') {\n                console.log('Age is not defined.');\n            } else {\n                console.log('Age is: ' + age);\n            }\n        "
    },
    {
      "name": "variable",
      "define": "A variable in JavaScript is a container used to store data values. Variables allow you to assign and access values throughout your code. JavaScript is a dynamically typed language, meaning variables can hold values of any data type, and their types can change during runtime.\n\nVariable Declaration and Assignment:\nTo declare a variable in JavaScript, you use the 'var', 'let', or 'const' keyword, followed by the variable name and optionally an initial value.\n\nExamples of variable declaration and assignment:\n// Using 'var' (global scope)\nvar age = 30;\n\n// Using 'let' (block scope)\nlet name = 'John';\n\n// Using 'const' (block scope, read-only)\nconst pi = 3.14;\n\nVariable Names:\nVariable names can consist of letters, digits, underscores, and dollar signs. They must start with a letter, underscore, or dollar sign (not a digit). JavaScript is case-sensitive, so 'myVar' and 'myvar' are considered different variables.\n\nExample of valid variable names:\nlet myVar = 42;\nlet _count = 10;\nlet $price = 20;\n\nVariable Scope:\nVariables can have either global scope or function/block scope, depending on where they are declared.\n\nGlobal Scope: Variables declared outside of any function or block have global scope, meaning they are accessible from anywhere in the code, including within functions.\n\nExample of a global variable:\nvar globalVar = 'I am global!';\n\nfunction myFunction() {\n    console.log(globalVar); // Output: \"I am global!\"\n}\n\nFunction/Block Scope: Variables declared inside a function or block have function/block scope and are accessible only within that specific function or block.\n\nExample of a function-scoped variable:\nfunction myFunction() {\n    var localVar = 'I am local!';\n    console.log(localVar);\n}\n\nconsole.log(localVar); // Error: localVar is not defined\n\nVariable Hoisting:\nIn JavaScript, variable declarations are hoisted to the top of their scope during the code execution phase. This means you can use a variable before declaring it, but its value will be 'undefined' until the assignment.\n\nExample of variable hoisting:\nconsole.log(myVar); // Output: undefined\nvar myVar = 42;\n\nIt's good practice to declare variables before using them to avoid unexpected behavior due to hoisting.\n\nConstant Variables:\nVariables declared with 'const' are read-only, meaning their values cannot be re-assigned once they are initialized. However, the contents of objects and arrays declared with 'const' can still be modified.\n\nExample of a constant variable:\nconst pi = 3.14;\npi = 3.14159; // Error: Assignment to constant variable.\n\nBy using variables, JavaScript developers can efficiently manage data, perform computations, and create more dynamic and interactive applications.",
      "example": "\n            // Example of using variables in JavaScript\n            let name = 'John';\n            var age = 30;\n            const PI = 3.14;\n\n            console.log(name); // Output: \"John\"\n            console.log(age); // Output: 30\n            console.log(PI); // Output: 3.14\n        "
    },
    {
      "name": "vue",
      "trigger": "vue js",
      "define": "Vue.js is a progressive JavaScript framework for building user interfaces (UIs) and single-page applications (SPAs). It is designed to be incrementally adoptable, allowing developers to integrate Vue.js into existing projects easily. Vue.js provides a robust and flexible ecosystem, making it a popular choice among front-end developers.\n\nKey Features of Vue.js:\n1. Declarative Rendering: Vue.js uses a template syntax that allows developers to declaratively render the UI based on the application's data state. The data and the DOM are automatically kept in sync, making it easy to build reactive applications.\n\nExample of declarative rendering in Vue.js:\n<div id=\"app\">\n    <p>{{ message }}</p>\n</div>\n\nvar app = new Vue({\n    el: '#app',\n    data: {\n        message: 'Hello, Vue.js!'\n    }\n});\n\n2. Component-Based Architecture: Vue.js encourages building UIs using reusable and modular components. Each component encapsulates its logic, template, and styles, making code organization and maintenance more manageable.\n\nExample of a Vue.js component:\nVue.component('my-component', {\n    template: '<div>{{ message }}</div>',\n    data() {\n        return {\n            message: 'Hello from Vue.js component!'\n        };\n    }\n});\n\n3. Directives: Vue.js provides built-in directives, such as 'v-if', 'v-for', and 'v-on', that allow developers to add dynamic behavior and interactivity to the HTML templates.\n\nExample of using directives in Vue.js:\n<div id=\"app\">\n    <p v-if=\"showMessage\">{{ message }}</p>\n    <button v-on:click=\"toggleMessage\">Toggle Message</button>\n</div>\n\nvar app = new Vue({\n    el: '#app',\n    data: {\n        message: 'Hello, Vue.js!',\n        showMessage: true\n    },\n    methods: {\n        toggleMessage() {\n            this.showMessage = !this.showMessage;\n        }\n    }\n});\n\n4. Vue Router: Vue.js provides an official routing library, Vue Router, that enables developers to implement client-side navigation and build SPAs with multiple views.\n\nExample of using Vue Router:\n// Main.js\nimport Vue from 'vue';\nimport VueRouter from 'vue-router';\nimport App from './App.vue';\nimport Home from './components/Home.vue';\nimport About from './components/About.vue';\n\nVue.use(VueRouter);\n\nconst routes = [\n    { path: '/', component: Home },\n    { path: '/about', component: About }\n];\n\nconst router = new VueRouter({\n    routes\n});\n\nnew Vue({\n    router,\n    render: h => h(App)\n}).$mount('#app');\n\n5. Vuex: Vuex is Vue.js's official state management library, providing a centralized store for managing the application's state and enabling efficient communication between components.\n\nExample of using Vuex:\n// Store.js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n\nVue.use(Vuex);\n\nexport default new Vuex.Store({\n    state: {\n        count: 0\n    },\n    mutations: {\n        increment(state) {\n            state.count++;\n        }\n    }\n});\n\n// Main.js\nimport Vue from 'vue';\nimport App from './App.vue';\nimport store from './store';\n\nnew Vue({\n    store,\n    render: h => h(App)\n}).$mount('#app');\n\nVue.js is a versatile framework suitable for projects of all sizes, from small-scale applications to large enterprise-level SPAs. Its flexibility, performance, and ease of integration with other libraries have contributed to its rapid growth and popularity in the web development community.",
      "example": "\n            // Example of using Vue.js to create a simple component\n            Vue.component('my-component', {\n                template: '<div>{{ message }}</div>',\n                data() {\n                    return {\n                        message: 'Hello from Vue.js component!'\n                    };\n                }\n            });\n\n            // Mount the component to the DOM\n            new Vue({\n                el: '#app'\n            });\n        "
    },
    {
      "name": "webpack",
      "trigger": "web pack",
      "define": "Webpack is a popular module bundler for JavaScript applications. It takes the various modules and assets in a project, such as JavaScript files, CSS styles, and images, and transforms them into optimized bundles suitable for deployment in the browser. Webpack simplifies the process of managing dependencies and improves the performance of web applications.\n\nKey Features of Webpack:\n1. Module Bundling: Webpack treats all code and assets in the project as modules, even JavaScript files, CSS styles, and images. It bundles these modules into a smaller number of files, reducing the number of HTTP requests and improving page load times.\n\nExample of module bundling with Webpack:\n// webpack.config.js\nmodule.exports = {\n    entry: './src/index.js',\n    output: {\n        filename: 'bundle.js',\n        path: path.resolve(__dirname, 'dist')\n    }\n};\n\n2. Loaders: Webpack uses loaders to process different types of files during the bundling process. Loaders enable developers to transform files from one format to another, apply transpilation, and perform various optimizations.\n\nExample of using loaders in Webpack for processing CSS files:\n// webpack.config.js\nmodule.exports = {\n    // ...\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [\n                    'style-loader', // Inject CSS into the DOM\n                    'css-loader' // Handle CSS imports\n                ]\n            }\n        ]\n    }\n};\n\n3. Plugins: Webpack plugins extend the bundling process with additional functionalities and optimizations. Plugins can be used for tasks such as code minification, environment variable injection, and code splitting.\n\nExample of using a plugin in Webpack for code minification:\n// webpack.config.js\nconst TerserPlugin = require('terser-webpack-plugin');\n\nmodule.exports = {\n    // ...\n    optimization: {\n        minimize: true,\n        minimizer: [new TerserPlugin()] // Minify JavaScript\n    }\n};\n\n4. Code Splitting: Webpack enables code splitting, allowing developers to split the application's code into multiple smaller chunks. This feature is beneficial for large applications as it reduces the initial loading time and improves overall performance.\n\nExample of code splitting in Webpack:\n// webpack.config.js\nmodule.exports = {\n    // ...\n    optimization: {\n        splitChunks: {\n            chunks: 'all'\n        }\n    }\n};\n\n5. Development Server: Webpack provides a built-in development server that allows developers to test and preview the application locally without deploying it to a production server.\n\nExample of using Webpack development server:\n// webpack.config.js\nmodule.exports = {\n    // ...\n    devServer: {\n        contentBase: path.join(__dirname, 'dist'),\n        port: 8080\n    }\n};\n\n6. Asset Management: Webpack supports various file formats, such as images, fonts, and videos, making it easy to handle static assets and include them in the bundles.\n\nExample of asset management in Webpack:\n// webpack.config.js\nmodule.exports = {\n    // ...\n    module: {\n        rules: [\n            {\n                test: /\\.(png|svg|jpg|gif)$/,\n                use: [\n                    'file-loader' // Handle image imports\n                ]\n            }\n        ]\n    }\n};\n\nWebpack is widely used in modern JavaScript development, especially in projects that use frameworks like React, Vue.js, or Angular. Its extensive range of features and active community support make it an essential tool for building efficient and well-organized web applications.",
      "example": "\n            // Example of using Webpack to bundle JavaScript modules\n            // webpack.config.js\n            const path = require('path');\n\n            module.exports = {\n                entry: './src/index.js',\n                output: {\n                    filename: 'bundle.js',\n                    path: path.resolve(__dirname, 'dist')\n                }\n            };\n        "
    },
    {
      "name": "yarn",
      "define": "Yarn is a fast, secure, and reliable package manager for JavaScript. It was developed by Facebook and is designed to be an alternative to npm (Node Package Manager). Yarn simplifies the process of managing dependencies, ensuring consistent installations, and speeding up package downloads.\n\nKey Features of Yarn:\n1. Dependency Management: Yarn helps manage project dependencies by automatically generating and updating a 'yarn.lock' file. This file ensures that the exact versions of dependencies are installed, guaranteeing consistency across different development environments.\n\nExample of using Yarn to install project dependencies:\n// Terminal\nyarn install\n\n2. Speed and Performance: Yarn is built with performance in mind. It uses a caching mechanism to speed up package installations, which results in faster overall development workflows.\n\nExample of using Yarn to install packages with caching:\n// Terminal\nyarn add lodash\n\n3. Workspaces: Yarn supports a feature called workspaces, which allows developers to manage multiple related packages within a single repository. This feature is beneficial for monorepo setups and complex projects.\n\nExample of using Yarn workspaces:\n// package.json\n{\n    \"private\": true,\n    \"workspaces\": [\n        \"packages/*\"\n    ]\n}\n\n4. Scripts: Yarn allows developers to define custom scripts in the 'package.json' file. These scripts can be used to automate various tasks, such as building, testing, and deploying the project.\n\nExample of using Yarn scripts in 'package.json':\n// package.json\n{\n    \"scripts\": {\n        \"start\": \"webpack --mode development\",\n        \"build\": \"webpack --mode production\",\n        \"test\": \"jest\"\n    }\n}\n\n5. Easy Upgrades: Yarn provides commands to update packages easily, either to their latest versions or to specific versions specified in the 'package.json' file.\n\nExample of using Yarn to update packages:\n// Terminal\nyarn upgrade\n\n6. Offline Mode: Yarn includes an offline mode, allowing developers to install packages without an internet connection, provided the packages have been cached previously.\n\nExample of using Yarn offline mode:\n// Terminal\nyarn install --offline\n\nYarn has gained significant popularity among JavaScript developers due to its speed, reliability, and powerful features. It continues to be a preferred choice for managing dependencies and improving development workflows in modern JavaScript projects.",
      "example": "\n            // Example of using Yarn to install packages\n            // Terminal\n            yarn add lodash\n\n            // Example of using Yarn scripts to run development server\n            // package.json\n            {\n                \"scripts\": {\n                    \"start\": \"webpack-dev-server --mode development\"\n                }\n            }\n        "
    },
    {
      "name": "Array",
      "define": "In JavaScript, an 'Array' is a special data structure that allows you to store a collection of elements, such as numbers, strings, objects, or even other arrays. Arrays are ordered, meaning the elements have a specific position, and you can access and modify them using their index.\n\nArrays in JavaScript can dynamically resize, meaning you can add or remove elements as needed. The size of an array is not fixed like in some other programming languages.\n\nExample (Defining and using an Array):\n// Defining an array with different types of elements\nlet myArray = [1, 'hello', true, { name: 'John' }];\n\n// Accessing elements in the array using index\nconsole.log(myArray[0]); // Output: 1\nconsole.log(myArray[1]); // Output: 'hello'\nconsole.log(myArray[2]); // Output: true\n\n// Modifying elements in the array\nmyArray[3] = { name: 'Jane' };\nconsole.log(myArray[3]); // Output: { name: 'Jane' }\n\n// Array length (number of elements in the array)\nconsole.log(myArray.length); // Output: 4\n\n\nSome commonly used Array Methods include:\n1. 'push()': Adds one or more elements to the end of an array and returns the new length of the array.\n2. 'pop()': Removes the last element from an array and returns that element.\n3. 'shift()': Removes the first element from an array and returns that element. The remaining elements' indices are shifted to lower positions.\n4. 'unshift()': Adds one or more elements to the beginning of an array and returns the new length of the array.\n5. 'splice()': Adds or removes elements from an array at a specified index.\n6. 'concat()': Combines two or more arrays and returns a new array.\n7. 'slice()': Extracts a section of an array and returns a new array without modifying the original array.\n8. 'indexOf()': Searches for an element in an array and returns its index. Returns -1 if the element is not found.\n9. 'lastIndexOf()': Searches for an element in an array from the end and returns its index. Returns -1 if the element is not found.\n10. 'includes()': Checks if an array includes a specific element and returns a boolean value.\n\n",
      "example": "\n            // Example 1:\n            // Defining an array with different types of elements\n            let myArray = [1, 'hello', true, { name: 'John' }];\n\n            // Accessing elements in the array using index\n            console.log(myArray[0]); // Output: 1\n            console.log(myArray[1]); // Output: 'hello'\n            console.log(myArray[2]); // Output: true\n\n            // Modifying elements in the array\n            myArray[3] = { name: 'Jane' };\n            console.log(myArray[3]); // Output: { name: 'Jane' }\n\n            // Array length (number of elements in the array)\n            console.log(myArray.length); // Output: 4\n        "
    },
    {
      "name": "every",
      "define": "'every' is a higher-order array method that tests whether all elements in the array pass a given condition (predicate) implemented by a callback function. It returns a boolean value, 'true' if all elements satisfy the condition, otherwise 'false'.\n\nThe 'every' method stops iterating and returns 'false' immediately when it encounters an element that does not meet the condition, making it efficient for certain use cases.\n\nExample (Using every to check if all numbers are positive):\nlet numbers = [1, 2, 3, 4, 5];\n\nlet allPositive = numbers.every(function(number) {\n    return number > 0;\n});\n\nconsole.log(allPositive); // Output: true\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n\n            let allPositive = numbers.every(function(number) {\n                return number > 0;\n            });\n\n            console.log(allPositive); // Output: true\n        "
    },
    {
      "name": "some",
      "define": "'some' is a higher-order array method that tests whether at least one element in the array passes a given condition (predicate) implemented by a callback function. It returns a boolean value, 'true' if at least one element satisfies the condition, otherwise 'false'.\n\nThe 'some' method stops iterating and returns 'true' immediately when it encounters an element that meets the condition, making it efficient for certain use cases.\n\nExample (Using some to check if any number is even):\nlet numbers = [1, 2, 3, 4, 5];\n\nlet hasEvenNumber = numbers.some(function(number) {\n    return number % 2 === 0;\n});\n\nconsole.log(hasEvenNumber); // Output: true\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n\n            let hasEvenNumber = numbers.some(function(number) {\n                return number % 2 === 0;\n            });\n\n            console.log(hasEvenNumber); // Output: true\n        "
    },
    {
      "name": "filter",
      "define": "'filter' is a higher-order array method that creates a new array containing elements from the original array that pass a given condition (predicate) implemented by a callback function. It returns an array with only the elements that satisfy the condition.\n\nThe 'filter' method does not modify the original array, and it returns a new array with the selected elements.\n\nExample (Using filter to get even numbers from an array):\nlet numbers = [1, 2, 3, 4, 5];\n\nlet evenNumbers = numbers.filter(function(number) {\n    return number % 2 === 0;\n});\n\nconsole.log(evenNumbers); // Output: [2, 4]\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n\n            let evenNumbers = numbers.filter(function(number) {\n                return number % 2 === 0;\n            });\n\n            console.log(evenNumbers); // Output: [2, 4]\n        "
    },
    {
      "name": "reduce",
      "define": "'reduce' is a higher-order array method that iterates through the array and accumulates a single value based on the elements in the array and a provided callback function. It \"reduces\" the array to a single value.\n\nThe callback function takes two arguments: the accumulator (the result of previous iterations) and the current element in the array. It returns the updated accumulator value for the next iteration.\n\nExample (Using reduce to find the sum of numbers in an array):\nlet numbers = [1, 2, 3, 4, 5];\n\nlet sum = numbers.reduce(function(accumulator, currentNumber) {\n    return accumulator + currentNumber;\n}, 0);\n\nconsole.log(sum); // Output: 15\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n\n            let sum = numbers.reduce(function(accumulator, currentNumber) {\n                return accumulator + currentNumber;\n            }, 0);\n\n            console.log(sum); // Output: 15\n        "
    },
    {
      "name": "find",
      "define": "'find' is a higher-order array method that returns the value of the first element in the array that satisfies a given condition (predicate) implemented by a callback function. It returns 'undefined' if no element satisfies the condition.\n\nThe 'find' method stops iterating and returns the first element that meets the condition, making it efficient for certain use cases.\n\nExample (Using find to get the first even number from an array):\nlet numbers = [1, 2, 3, 4, 5];\n\nlet firstEvenNumber = numbers.find(function(number) {\n    return number % 2 === 0;\n});\n\nconsole.log(firstEvenNumber); // Output: 2\n",
      "example": "\n            // Example 1:\n            let numbers = [1, 2, 3, 4, 5];\n\n            let firstEvenNumber = numbers.find(function(number) {\n                return number % 2 === 0;\n            });\n\n            console.log(firstEvenNumber); // Output: 2\n        "
    },
    {
      "name": "Microservices Architecture",
      "trigger": "micro services",
      "define": "Microservices Architecture is an architectural style used in software development that structures an application as a collection of small, independent, and loosely coupled services. Each service is responsible for a specific business capability and can be developed, deployed, and scaled independently. Microservices aim to break down a monolithic application into smaller, manageable components, allowing teams to work on individual services independently, facilitating faster development and deployment cycles.\n\nMicroservices communicate with each other through well-defined APIs, often using lightweight protocols like HTTP/REST or messaging systems like RabbitMQ or Apache Kafka. This decentralized communication enables services to evolve and scale independently without affecting the entire application.\n\nKey Characteristics of Microservices Architecture:\n1. Decentralization: Each microservice is an autonomous unit that can be developed and deployed independently, promoting decentralized decision-making and development.\n2. Loosely Coupled: Microservices are designed to have minimal dependencies on other services, reducing the impact of changes and allowing for flexible deployments.\n3. Single Responsibility: Each service focuses on a specific business capability or feature, adhering to the Single Responsibility Principle.\n4. Independent Scalability: Services can be scaled individually based on their specific demand, optimizing resource utilization.\n5. Technology Diversity: Microservices allow the use of different programming languages, frameworks, and databases for each service based on its requirements.\n6. Resilience: Failure in one service should not cascade to other services, as they are designed to be resilient and handle failures gracefully.\n7. Continuous Delivery: Microservices encourage automated deployment and continuous delivery practices, streamlining the software development process.\n8. Containerization: Services are often deployed in containers like Docker, providing consistency and portability across different environments.\n9. Observability: Monitoring, logging, and tracing are essential in a microservices architecture to gain insights into the behavior and performance of services.\n10. Evolutionary Design: Microservices promote evolutionary design, allowing the application to adapt to changing business needs over time.\n\nIt's essential to note that while microservices offer several benefits, they also introduce additional complexities, such as managing inter-service communication, dealing with eventual consistency, and ensuring data integrity across services. Proper planning and infrastructure are required to implement and maintain a successful microservices architecture in a real-world application.",
      "example": "N/A - Microservices architecture is an architectural style, and examples would require designing and implementing a complete microservices-based application, which is beyond the scope of a simple code snippet."
    },
    {
      "name": "Primitives",
      "trigger": "javascript primitives",
      "define": "JavaScript Primitives are the basic data types in JavaScript that represent single values. There are six primitive data types in JavaScript: \n        1. Number: Represents numeric values, including integers and floating-point numbers.\n        2. String: Represents sequences of characters enclosed in single ('') or double (\"\") quotes.\n        3. Boolean: Represents true or false values for logical operations.\n        4. Undefined: Represents a variable that has been declared but not assigned a value.\n        5. Null: Represents the intentional absence of any object value.\n        6. Symbol: Represents unique, immutable values that are often used as object property keys to avoid name collisions.\n\nPrimitive values are immutable, meaning their values cannot be changed once they are created. When you assign a primitive value to a variable or pass it as an argument to a function, you are working with a copy of the actual value rather than a reference to it.",
      "example": "\n            // Examples of JavaScript Primitives\n            const numberValue = 42; // Number\n            const stringValue = 'Hello, World!'; // String\n            const booleanValue = true; // Boolean\n            let undefinedValue; // Undefined\n            const nullValue = null; // Null\n\n            // Example of using Symbol\n            const symbolValue = Symbol('mySymbol');\n        "
    },
    {
      "name": "Objects",
      "trigger": "javascript objects",
      "define": "JavaScript Objects are complex data types used to store collections of key-value pairs. They represent entities with properties and behaviors. Objects are one of the fundamental building blocks in JavaScript, and almost everything in JavaScript is an object or behaves like one. Objects are used to model real-world entities and abstract data structures.\n\nIn JavaScript, objects are defined using curly braces {} and consist of properties, where each property has a name (key) and a value. The value of a property can be a primitive value, another object, or a function (in which case, the property is called a method).\n\nUnlike primitives, objects are mutable, which means their properties can be modified after creation. However, when you assign an object to a variable or pass it as an argument to a function, you are working with a reference to the object, not a copy of its value. Modifying an object's property through one reference affects all other references to that object.",
      "example": "\n            // Example of JavaScript Objects\n            const person = {\n              name: 'John Doe',\n              age: 30,\n              city: 'New York',\n              hobbies: ['reading', 'coding', 'swimming'],\n              address: {\n                street: '123 Main St',\n                zipCode: '10001',\n              },\n              sayHello: function() {\n                console.log('Hello, I am ' + this.name);\n              },\n            };\n\n            console.log(person.name); // Output: 'John Doe'\n            console.log(person.hobbies[1]); // Output: 'coding'\n            person.age = 31; // Modifying a property\n            person.sayHello(); // Output: 'Hello, I am John Doe'\n\n            // Example of object reference\n            const personReference = person; // Creating a reference\n            personReference.name = 'Jane Doe'; // Modifying the object through the reference\n            console.log(person.name); // Output: 'Jane Doe' (as the object was modified through the reference)\n        "
    },
    {
      "name": "microservices",
      "trigger": "micro services",
      "define": "Microservices, also known as the microservices architecture, is an architectural style that structures an application as a collection of loosely coupled services. In a microservices architecture, services should be fine-grained, and the protocols should be lightweight. The benefit of decomposing an application into different smaller services is that it improves modularity and makes the application easier to understand, develop, and test.\n\nThe core principles of microservices are:\n\n1. Single Responsibility:\nEach microservice should have a single responsibility and should do that task well. This concept is similar to the Single Responsibility Principle from SOLID principles in object-oriented design.\n\n2. Business-Centric:\nEach microservice should represent a small business capability. This allows the team to focus on one area of the business at a time.\n\n3. Autonomy:\nMicroservices can be developed, deployed, scaled, and even taken down independently without affecting the whole system.\n\n4. Decentralized Governance:\nThere is no need for a centralized governing body, and each microservice can use its own technique and technology, best suited for its requirement.\n\n5. Failure Isolation:\nFailure in one microservice should not affect other services or the entire application.\n\n6. Continuous Delivery:\nEach microservice can be managed by a small team who takes care of the lifecycle, from development, testing, deployment to monitoring, and maintenance.\n\n7. Infrastructure Automation:\nWith the help of containerization (like Docker) and orchestration tools (like Kubernetes), microservices can be easily automated for deployment, scaling, and recovery.\n\nThe advantages of using microservices are:\n\nIndependence: Individual components can evolve independently, reducing the coordination overhead in project management.\nScalability: Different components have different resource requirements, and this can be a much more cost-effective way to scale the application.\nResilience: If a single component failure were to occur, the rest of the application can potentially continue to function.\nReusability: Components can be reused across different projects.\nHowever, there are also challenges:\n\nInter-Service Communication: The various services need to communicate. This communication framework needs to be robust and efficient. Typically, APIs are used for this purpose.\nData Consistency: Each service has its own database to ensure loose coupling. Managing consistency across services is a challenge.\nTesting and Deployment: Writing effective tests for microservices-based applications can be complex, as can deploying a multi-service application.\n        ",
      "example": ""
    }
  ]
}